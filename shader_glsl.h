"// ambient+diffuse+specular+normalmap+attenuation+cubemap+fog shader\n"
"// written by Forest 'LordHavoc' Hale\n"
"// shadowmapping enhancements by Lee 'eihrul' Salzman\n"
"\n"
"// GL ES shaders use precision modifiers, standard GL does not\n"
"#ifndef GL_ES\n"
"#define lowp\n"
"#define mediump\n"
"#define highp\n"
"#endif\n"
"\n"
"#ifdef VERTEX_SHADER\n"
"attribute vec4 Attrib_Position;  // vertex\n"
"attribute vec4 Attrib_Color;     // color\n"
"attribute vec4 Attrib_TexCoord0; // material texcoords\n"
"attribute vec3 Attrib_TexCoord1; // svector\n"
"attribute vec3 Attrib_TexCoord2; // tvector\n"
"attribute vec3 Attrib_TexCoord3; // normal\n"
"attribute vec4 Attrib_TexCoord4; // lightmap texcoords\n"
"#endif\n"
"varying lowp vec4 VertexColor;\n"
"\n"
"#if defined(USEFOGINSIDE) || defined(USEFOGOUTSIDE) || defined(USEFOGHEIGHTTEXTURE)\n"
"# define USEFOG\n"
"#endif\n"
"#if defined(MODE_LIGHTMAP) || defined(MODE_LIGHTDIRECTIONMAP_MODELSPACE) || defined(MODE_LIGHTDIRECTIONMAP_TANGENTSPACE)\n"
"#define USELIGHTMAP\n"
"#endif\n"
"#if defined(USESPECULAR) || defined(USEOFFSETMAPPING) || defined(USEREFLECTCUBE) || defined(MODE_FAKELIGHT)\n"
"#define USEEYEVECTOR\n"
"#endif\n"
"\n"
"#ifdef USESHADOWMAP2D\n"
"# ifdef GL_EXT_gpu_shader4\n"
"#   extension GL_EXT_gpu_shader4 : enable\n"
"# endif\n"
"# ifdef GL_ARB_texture_gather\n"
"#   extension GL_ARB_texture_gather : enable\n"
"# else\n"
"#   ifdef GL_AMD_texture_texture4\n"
"#     extension GL_AMD_texture_texture4 : enable\n"
"#   endif\n"
"# endif\n"
"#endif\n"
"\n"
"//#ifdef USESHADOWSAMPLER\n"
"//# extension GL_ARB_shadow : enable\n"
"//#endif\n"
"\n"
"//#ifdef __GLSL_CG_DATA_TYPES\n"
"//# define myhalf half\n"
"//# define myhalf2 half2\n"
"//# define myhalf3 half3\n"
"//# define myhalf4 half4\n"
"//#else\n"
"# define myhalf mediump float\n"
"# define myhalf2 mediump vec2\n"
"# define myhalf3 mediump vec3\n"
"# define myhalf4 mediump vec4\n"
"//#endif\n"
"\n"
"#ifdef VERTEX_SHADER\n"
"uniform highp mat4 ModelViewProjectionMatrix;\n"
"#endif\n"
"\n"
"#ifdef MODE_DEPTH_OR_SHADOW\n"
"#ifdef VERTEX_SHADER\n"
"void main(void)\n"
"{\n"
"	gl_Position = ModelViewProjectionMatrix * Attrib_Position;\n"
"}\n"
"#endif\n"
"#else // !MODE_DEPTH_ORSHADOW\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_SHOWDEPTH\n"
"#ifdef VERTEX_SHADER\n"
"void main(void)\n"
"{\n"
"	gl_Position = ModelViewProjectionMatrix * Attrib_Position;\n"
"	VertexColor = vec4(gl_Position.z, gl_Position.z, gl_Position.z, 1.0);\n"
"}\n"
"#endif\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"void main(void)\n"
"{\n"
"	gl_FragColor = VertexColor;\n"
"}\n"
"#endif\n"
"#else // !MODE_SHOWDEPTH\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_POSTPROCESS\n"
"varying mediump vec2 TexCoord1;\n"
"varying mediump vec2 TexCoord2;\n"
"\n"
"#ifdef VERTEX_SHADER\n"
"void main(void)\n"
"{\n"
"	gl_Position = ModelViewProjectionMatrix * Attrib_Position;\n"
"	TexCoord1 = Attrib_TexCoord0.xy;\n"
"#ifdef USEBLOOM\n"
"	TexCoord2 = Attrib_TexCoord4.xy;\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"uniform sampler2D Texture_First;\n"
"#ifdef USEBLOOM\n"
"uniform sampler2D Texture_Second;\n"
"uniform lowp vec4 BloomColorSubtract;\n"
"#endif\n"
"#ifdef USEGAMMARAMPS\n"
"uniform sampler2D Texture_GammaRamps;\n"
"#endif\n"
"#ifdef USESATURATION\n"
"uniform lowp float Saturation;\n"
"#endif\n"
"#ifdef USEVIEWTINT\n"
"uniform lowp vec4 ViewTintColor;\n"
"#endif\n"
"//uncomment these if you want to use them:\n"
"uniform mediump vec4 UserVec1;\n"
"uniform mediump vec4 UserVec2;\n"
"// uniform mediump vec4 UserVec3;\n"
"// uniform mediump vec4 UserVec4;\n"
"// uniform highp float ClientTime;\n"
"uniform mediump vec2 PixelSize;\n"
"void main(void)\n"
"{\n"
"	gl_FragColor = texture2D(Texture_First, TexCoord1);\n"
"#ifdef USEBLOOM\n"
"	gl_FragColor += max(vec4(0,0,0,0), texture2D(Texture_Second, TexCoord2) - BloomColorSubtract);\n"
"#endif\n"
"#ifdef USEVIEWTINT\n"
"	gl_FragColor = mix(gl_FragColor, ViewTintColor, ViewTintColor.a);\n"
"#endif\n"
"\n"
"#ifdef USEPOSTPROCESSING\n"
"// do r_glsl_dumpshader, edit glsl/default.glsl, and replace this by your own postprocessing if you want\n"
"// this code does a blur with the radius specified in the first component of r_glsl_postprocess_uservec1 and blends it using the second component\n"
"	float sobel = 1.0;\n"
"	// vec2 ts = textureSize(Texture_First, 0);\n"
"	// vec2 px = vec2(1/ts.x, 1/ts.y);\n"
"	vec2 px = PixelSize;\n"
"	vec3 x1 = texture2D(Texture_First, TexCoord1 + vec2(-px.x, px.y)).rgb;\n"
"	vec3 x2 = texture2D(Texture_First, TexCoord1 + vec2(-px.x,  0.0)).rgb;\n"
"	vec3 x3 = texture2D(Texture_First, TexCoord1 + vec2(-px.x,-px.y)).rgb;\n"
"	vec3 x4 = texture2D(Texture_First, TexCoord1 + vec2( px.x, px.y)).rgb;\n"
"	vec3 x5 = texture2D(Texture_First, TexCoord1 + vec2( px.x,  0.0)).rgb;\n"
"	vec3 x6 = texture2D(Texture_First, TexCoord1 + vec2( px.x,-px.y)).rgb;\n"
"	vec3 y1 = texture2D(Texture_First, TexCoord1 + vec2( px.x,-px.y)).rgb;\n"
"	vec3 y2 = texture2D(Texture_First, TexCoord1 + vec2(  0.0,-px.y)).rgb;\n"
"	vec3 y3 = texture2D(Texture_First, TexCoord1 + vec2(-px.x,-px.y)).rgb;\n"
"	vec3 y4 = texture2D(Texture_First, TexCoord1 + vec2( px.x, px.y)).rgb;\n"
"	vec3 y5 = texture2D(Texture_First, TexCoord1 + vec2(  0.0, px.y)).rgb;\n"
"	vec3 y6 = texture2D(Texture_First, TexCoord1 + vec2(-px.x, px.y)).rgb;\n"
"	float px1 = -1.0 * dot(vec3(0.3, 0.59, 0.11), x1);\n"
"	float px2 = -2.0 * dot(vec3(0.3, 0.59, 0.11), x2);\n"
"	float px3 = -1.0 * dot(vec3(0.3, 0.59, 0.11), x3);\n"
"	float px4 =  1.0 * dot(vec3(0.3, 0.59, 0.11), x4);\n"
"	float px5 =  2.0 * dot(vec3(0.3, 0.59, 0.11), x5);\n"
"	float px6 =  1.0 * dot(vec3(0.3, 0.59, 0.11), x6);\n"
"	float py1 = -1.0 * dot(vec3(0.3, 0.59, 0.11), y1);\n"
"	float py2 = -2.0 * dot(vec3(0.3, 0.59, 0.11), y2);\n"
"	float py3 = -1.0 * dot(vec3(0.3, 0.59, 0.11), y3);\n"
"	float py4 =  1.0 * dot(vec3(0.3, 0.59, 0.11), y4);\n"
"	float py5 =  2.0 * dot(vec3(0.3, 0.59, 0.11), y5);\n"
"	float py6 =  1.0 * dot(vec3(0.3, 0.59, 0.11), y6);\n"
"	sobel = 0.25 * abs(px1 + px2 + px3 + px4 + px5 + px6) + 0.25 * abs(py1 + py2 + py3 + py4 + py5 + py6);\n"
"	gl_FragColor += texture2D(Texture_First, TexCoord1 + PixelSize*UserVec1.x*vec2(-0.987688, -0.156434)) * UserVec1.y;\n"
"	gl_FragColor += texture2D(Texture_First, TexCoord1 + PixelSize*UserVec1.x*vec2(-0.156434, -0.891007)) * UserVec1.y;\n"
"	gl_FragColor += texture2D(Texture_First, TexCoord1 + PixelSize*UserVec1.x*vec2( 0.891007, -0.453990)) * UserVec1.y;\n"
"	gl_FragColor += texture2D(Texture_First, TexCoord1 + PixelSize*UserVec1.x*vec2( 0.707107,  0.707107)) * UserVec1.y;\n"
"	gl_FragColor += texture2D(Texture_First, TexCoord1 + PixelSize*UserVec1.x*vec2(-0.453990,  0.891007)) * UserVec1.y;\n"
"	gl_FragColor /= (1.0 + 5.0 * UserVec1.y);\n"
"	gl_FragColor.rgb = gl_FragColor.rgb * (1.0 + UserVec2.x) + vec3(max(0.0, sobel - UserVec2.z))*UserVec2.y;\n"
"#endif\n"
"\n"
"#ifdef USESATURATION\n"
"	//apply saturation BEFORE gamma ramps, so v_glslgamma value does not matter\n"
"	float y = dot(gl_FragColor.rgb, vec3(0.299, 0.587, 0.114));\n"
"	// 'vampire sight' effect, wheres red is compensated\n"
"	#ifdef SATURATION_REDCOMPENSATE\n"
"		float rboost = max(0.0, (gl_FragColor.r - max(gl_FragColor.g, gl_FragColor.b))*(1.0 - Saturation));\n"
"		gl_FragColor.rgb = mix(vec3(y), gl_FragColor.rgb, Saturation);\n"
"		gl_FragColor.r += rboost;\n"
"	#else\n"
"		// normal desaturation\n"
"		//gl_FragColor = vec3(y) + (gl_FragColor.rgb - vec3(y)) * Saturation;\n"
"		gl_FragColor.rgb = mix(vec3(y), gl_FragColor.rgb, Saturation);\n"
"	#endif\n"
"#endif\n"
"\n"
"#ifdef USEGAMMARAMPS\n"
"	gl_FragColor.r = texture2D(Texture_GammaRamps, vec2(gl_FragColor.r, 0)).r;\n"
"	gl_FragColor.g = texture2D(Texture_GammaRamps, vec2(gl_FragColor.g, 0)).g;\n"
"	gl_FragColor.b = texture2D(Texture_GammaRamps, vec2(gl_FragColor.b, 0)).b;\n"
"#endif\n"
"}\n"
"#endif\n"
"#else // !MODE_POSTPROCESS\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_GENERIC\n"
"#ifdef USEDIFFUSE\n"
"varying mediump vec2 TexCoord1;\n"
"#endif\n"
"#ifdef USESPECULAR\n"
"varying mediump vec2 TexCoord2;\n"
"#endif\n"
"#ifdef VERTEX_SHADER\n"
"void main(void)\n"
"{\n"
"	VertexColor = Attrib_Color;\n"
"#ifdef USEDIFFUSE\n"
"	TexCoord1 = Attrib_TexCoord0.xy;\n"
"#endif\n"
"#ifdef USESPECULAR\n"
"	TexCoord2 = Attrib_TexCoord1.xy;\n"
"#endif\n"
"	gl_Position = ModelViewProjectionMatrix * Attrib_Position;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"#ifdef USEDIFFUSE\n"
"uniform sampler2D Texture_First;\n"
"#endif\n"
"#ifdef USESPECULAR\n"
"uniform sampler2D Texture_Second;\n"
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"#ifdef USEVIEWTINT\n"
"	gl_FragColor = VertexColor;\n"
"#else\n"
"	gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n"
"#endif\n"
"#ifdef USEDIFFUSE\n"
"	gl_FragColor *= texture2D(Texture_First, TexCoord1);\n"
"#endif\n"
"\n"
"#ifdef USESPECULAR\n"
"	vec4 tex2 = texture2D(Texture_Second, TexCoord2);\n"
"# ifdef USECOLORMAPPING\n"
"	gl_FragColor *= tex2;\n"
"# endif\n"
"# ifdef USEGLOW\n"
"	gl_FragColor += tex2;\n"
"# endif\n"
"# ifdef USEVERTEXTEXTUREBLEND\n"
"	gl_FragColor = mix(gl_FragColor, tex2, tex2.a);\n"
"# endif\n"
"#endif\n"
"}\n"
"#endif\n"
"#else // !MODE_GENERIC\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_BLOOMBLUR\n"
"varying mediump vec2 TexCoord;\n"
"#ifdef VERTEX_SHADER\n"
"void main(void)\n"
"{\n"
"	VertexColor = Attrib_Color;\n"
"	TexCoord = Attrib_TexCoord0.xy;\n"
"	gl_Position = ModelViewProjectionMatrix * Attrib_Position;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"uniform sampler2D Texture_First;\n"
"uniform mediump vec4 BloomBlur_Parameters;\n"
"\n"
"void main(void)\n"
"{\n"
"	int i;\n"
"	vec2 tc = TexCoord;\n"
"	vec3 color = texture2D(Texture_First, tc).rgb;\n"
"	tc += BloomBlur_Parameters.xy;\n"
"	for (i = 1;i < SAMPLES;i++)\n"
"	{\n"
"		color += texture2D(Texture_First, tc).rgb;\n"
"		tc += BloomBlur_Parameters.xy;\n"
"	}\n"
"	gl_FragColor = vec4(color * BloomBlur_Parameters.z + vec3(BloomBlur_Parameters.w), 1);\n"
"}\n"
"#endif\n"
"#else // !MODE_BLOOMBLUR\n"
"#ifdef MODE_REFRACTION\n"
"varying mediump vec2 TexCoord;\n"
"varying highp vec4 ModelViewProjectionPosition;\n"
"uniform highp mat4 TexMatrix;\n"
"#ifdef VERTEX_SHADER\n"
"\n"
"void main(void)\n"
"{\n"
"	TexCoord = vec2(TexMatrix * Attrib_TexCoord0);\n"
"	gl_Position = ModelViewProjectionMatrix * Attrib_Position;\n"
"	ModelViewProjectionPosition = gl_Position;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"uniform sampler2D Texture_Normal;\n"
"uniform sampler2D Texture_Refraction;\n"
"uniform sampler2D Texture_Reflection;\n"
"\n"
"uniform mediump vec4 DistortScaleRefractReflect;\n"
"uniform mediump vec4 ScreenScaleRefractReflect;\n"
"uniform mediump vec4 ScreenCenterRefractReflect;\n"
"uniform lowp vec4 RefractColor;\n"
"uniform lowp vec4 ReflectColor;\n"
"uniform mediump float ReflectFactor;\n"
"uniform mediump float ReflectOffset;\n"
"\n"
"void main(void)\n"
"{\n"
"	vec2 ScreenScaleRefractReflectIW = ScreenScaleRefractReflect.xy * (1.0 / ModelViewProjectionPosition.w);\n"
"	//vec2 ScreenTexCoord = (ModelViewProjectionPosition.xy + normalize(vec3(texture2D(Texture_Normal, TexCoord)) - vec3(0.5)).xy * DistortScaleRefractReflect.xy * 100) * ScreenScaleRefractReflectIW + ScreenCenterRefractReflect.xy;\n"
"	vec2 SafeScreenTexCoord = ModelViewProjectionPosition.xy * ScreenScaleRefractReflectIW + ScreenCenterRefractReflect.xy;\n"
"	vec2 ScreenTexCoord = SafeScreenTexCoord + vec2(normalize(vec3(texture2D(Texture_Normal, TexCoord)) - vec3(0.5))).xy * DistortScaleRefractReflect.xy;\n"
"	// FIXME temporary hack to detect the case that the reflection\n"
"	// gets blackened at edges due to leaving the area that contains actual\n"
"	// content.\n"
"	// Remove this 'ack once we have a better way to stop this thing from\n"
"	// 'appening.\n"
"	float f = min(1.0, length(texture2D(Texture_Refraction, ScreenTexCoord + vec2(0.01, 0.01)).rgb) / 0.05);\n"
"	f      *= min(1.0, length(texture2D(Texture_Refraction, ScreenTexCoord + vec2(0.01, -0.01)).rgb) / 0.05);\n"
"	f      *= min(1.0, length(texture2D(Texture_Refraction, ScreenTexCoord + vec2(-0.01, 0.01)).rgb) / 0.05);\n"
"	f      *= min(1.0, length(texture2D(Texture_Refraction, ScreenTexCoord + vec2(-0.01, -0.01)).rgb) / 0.05);\n"
"	ScreenTexCoord = mix(SafeScreenTexCoord, ScreenTexCoord, f);\n"
"	gl_FragColor = vec4(texture2D(Texture_Refraction, ScreenTexCoord).rgb, 1.0) * RefractColor;\n"
"}\n"
"#endif\n"
"#else // !MODE_REFRACTION\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_WATER\n"
"varying mediump vec2 TexCoord;\n"
"varying highp vec3 EyeVector;\n"
"varying highp vec4 ModelViewProjectionPosition;\n"
"#ifdef VERTEX_SHADER\n"
"uniform highp vec3 EyePosition;\n"
"uniform highp mat4 TexMatrix;\n"
"\n"
"void main(void)\n"
"{\n"
"	TexCoord = vec2(TexMatrix * Attrib_TexCoord0);\n"
"	vec3 EyeVectorModelSpace = EyePosition - Attrib_Position.xyz;\n"
"	EyeVector.x = dot(EyeVectorModelSpace, Attrib_TexCoord1.xyz);\n"
"	EyeVector.y = dot(EyeVectorModelSpace, Attrib_TexCoord2.xyz);\n"
"	EyeVector.z = dot(EyeVectorModelSpace, Attrib_TexCoord3.xyz);\n"
"	gl_Position = ModelViewProjectionMatrix * Attrib_Position;\n"
"	ModelViewProjectionPosition = gl_Position;\n"
"}\n"
"#endif\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"uniform sampler2D Texture_Normal;\n"
"uniform sampler2D Texture_Refraction;\n"
"uniform sampler2D Texture_Reflection;\n"
"\n"
"uniform mediump vec4 DistortScaleRefractReflect;\n"
"uniform mediump vec4 ScreenScaleRefractReflect;\n"
"uniform mediump vec4 ScreenCenterRefractReflect;\n"
"uniform lowp vec4 RefractColor;\n"
"uniform lowp vec4 ReflectColor;\n"
"uniform mediump float ReflectFactor;\n"
"uniform mediump float ReflectOffset;\n"
"uniform highp float ClientTime;\n"
"#ifdef USENORMALMAPSCROLLBLEND\n"
"uniform highp vec2 NormalmapScrollBlend;\n"
"#endif\n"
"\n"
"void main(void)\n"
"{\n"
"	vec4 ScreenScaleRefractReflectIW = ScreenScaleRefractReflect * (1.0 / ModelViewProjectionPosition.w);\n"
"	//vec4 ScreenTexCoord = (ModelViewProjectionPosition.xyxy + normalize(vec3(texture2D(Texture_Normal, TexCoord)) - vec3(0.5)).xyxy * DistortScaleRefractReflect * 100) * ScreenScaleRefractReflectIW + ScreenCenterRefractReflect;\n"
"	vec4 SafeScreenTexCoord = ModelViewProjectionPosition.xyxy * ScreenScaleRefractReflectIW + ScreenCenterRefractReflect;\n"
"	//SafeScreenTexCoord = gl_FragCoord.xyxy * vec4(1.0 / 1920.0, 1.0 / 1200.0, 1.0 / 1920.0, 1.0 / 1200.0);\n"
"	// slight water animation via 2 layer scrolling (todo: tweak)\n"
"	#ifdef USENORMALMAPSCROLLBLEND\n"
"		vec3 normal = texture2D(Texture_Normal, (TexCoord + vec2(0.08, 0.08)*ClientTime*NormalmapScrollBlend.x*0.5)*NormalmapScrollBlend.y).rgb - vec3(1.0);\n"
"		normal += texture2D(Texture_Normal, (TexCoord + vec2(-0.06, -0.09)*ClientTime*NormalmapScrollBlend.x)*NormalmapScrollBlend.y*0.75).rgb;\n"
"		vec4 ScreenTexCoord = SafeScreenTexCoord + vec2(normalize(normal) + vec3(0.15)).xyxy * DistortScaleRefractReflect;\n"
"	#else\n"
"		vec4 ScreenTexCoord = SafeScreenTexCoord + vec2(normalize(vec3(texture2D(Texture_Normal, TexCoord)) - vec3(0.5))).xyxy * DistortScaleRefractReflect;\n"
"	#endif\n"
"	// FIXME temporary hack to detect the case that the reflection\n"
"	// gets blackened at edges due to leaving the area that contains actual\n"
"	// content.\n"
"	// Remove this 'ack once we have a better way to stop this thing from\n"
"	// 'appening.\n"
"	float f  = min(1.0, length(texture2D(Texture_Refraction, ScreenTexCoord.xy + vec2(0.005, 0.01)).rgb) / 0.002);\n"
"	f       *= min(1.0, length(texture2D(Texture_Refraction, ScreenTexCoord.xy + vec2(0.005, -0.01)).rgb) / 0.002);\n"
"	f       *= min(1.0, length(texture2D(Texture_Refraction, ScreenTexCoord.xy + vec2(-0.005, 0.01)).rgb) / 0.002);\n"
"	f       *= min(1.0, length(texture2D(Texture_Refraction, ScreenTexCoord.xy + vec2(-0.005, -0.01)).rgb) / 0.002);\n"
"	ScreenTexCoord.xy = mix(SafeScreenTexCoord.xy, ScreenTexCoord.xy, f);\n"
"	f  = min(1.0, length(texture2D(Texture_Reflection, ScreenTexCoord.zw + vec2(0.005, 0.005)).rgb) / 0.002);\n"
"	f *= min(1.0, length(texture2D(Texture_Reflection, ScreenTexCoord.zw + vec2(0.005, -0.005)).rgb) / 0.002);\n"
"	f *= min(1.0, length(texture2D(Texture_Reflection, ScreenTexCoord.zw + vec2(-0.005, 0.005)).rgb) / 0.002);\n"
"	f *= min(1.0, length(texture2D(Texture_Reflection, ScreenTexCoord.zw + vec2(-0.005, -0.005)).rgb) / 0.002);\n"
"	ScreenTexCoord.zw = mix(SafeScreenTexCoord.zw, ScreenTexCoord.zw, f);\n"
"	float Fresnel = pow(min(1.0, 1.0 - float(normalize(EyeVector).z)), 2.0) * ReflectFactor + ReflectOffset;\n"
"	gl_FragColor = mix(vec4(texture2D(Texture_Refraction, ScreenTexCoord.xy).rgb, 1) * RefractColor, vec4(texture2D(Texture_Reflection, ScreenTexCoord.zw).rgb, 1) * ReflectColor, Fresnel);\n"
"}\n"
"#endif\n"
"#else // !MODE_WATER\n"
"\n"
"\n"
"\n"
"\n"
"// common definitions between vertex shader and fragment shader:\n"
"\n"
"varying mediump vec4 TexCoordSurfaceLightmap;\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"varying mediump vec2 TexCoord2;\n"
"#endif\n"
"\n"
"#ifdef MODE_LIGHTSOURCE\n"
"varying mediump vec3 CubeVector;\n"
"#endif\n"
"\n"
"#if (defined(MODE_LIGHTSOURCE) || defined(MODE_LIGHTDIRECTION)) && defined(USEDIFFUSE)\n"
"varying mediump vec3 LightVector;\n"
"#endif\n"
"\n"
"#ifdef USEEYEVECTOR\n"
"varying highp vec3 EyeVector;\n"
"#endif\n"
"#ifdef USEFOG\n"
"varying highp vec4 EyeVectorModelSpaceFogPlaneVertexDist;\n"
"#endif\n"
"\n"
"#if defined(MODE_LIGHTDIRECTIONMAP_MODELSPACE) || defined(MODE_DEFERREDGEOMETRY) || defined(USEREFLECTCUBE)\n"
"varying lowp vec3 VectorS; // direction of S texcoord (sometimes crudely called tangent)\n"
"varying lowp vec3 VectorT; // direction of T texcoord (sometimes crudely called binormal)\n"
"varying lowp vec3 VectorR; // direction of R texcoord (surface normal)\n"
"#endif\n"
"\n"
"#ifdef USEREFLECTION\n"
"varying highp vec4 ModelViewProjectionPosition;\n"
"#endif\n"
"#ifdef MODE_DEFERREDLIGHTSOURCE\n"
"uniform highp vec3 LightPosition;\n"
"varying highp vec4 ModelViewPosition;\n"
"#endif\n"
"\n"
"#ifdef MODE_LIGHTSOURCE\n"
"uniform highp vec3 LightPosition;\n"
"#endif\n"
"uniform highp vec3 EyePosition;\n"
"#ifdef MODE_LIGHTDIRECTION\n"
"uniform highp vec3 LightDir;\n"
"#endif\n"
"uniform highp vec4 FogPlane;\n"
"\n"
"#ifdef USESHADOWMAPORTHO\n"
"varying mediump vec3 ShadowMapTC;\n"
"#endif\n"
"\n"
"#ifdef USEBOUNCEGRID\n"
"varying mediump vec3 BounceGridTexCoord;\n"
"#endif\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"// TODO: get rid of tangentt (texcoord2) and use a crossproduct to regenerate it from tangents (texcoord1) and normal (texcoord3), this would require sending a 4 component texcoord1 with W as 1 or -1 according to which side the texcoord2 should be on\n"
"\n"
"// fragment shader specific:\n"
"#ifdef FRAGMENT_SHADER\n"
"\n"
"uniform sampler2D Texture_Normal;\n"
"uniform sampler2D Texture_Color;\n"
"uniform sampler2D Texture_Gloss;\n"
"#ifdef USEGLOW\n"
"uniform sampler2D Texture_Glow;\n"
"#endif\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"uniform sampler2D Texture_SecondaryNormal;\n"
"uniform sampler2D Texture_SecondaryColor;\n"
"uniform sampler2D Texture_SecondaryGloss;\n"
"#ifdef USEGLOW\n"
"uniform sampler2D Texture_SecondaryGlow;\n"
"#endif\n"
"#endif\n"
"#ifdef USECOLORMAPPING\n"
"uniform sampler2D Texture_Pants;\n"
"uniform sampler2D Texture_Shirt;\n"
"#endif\n"
"#ifdef USEFOG\n"
"#ifdef USEFOGHEIGHTTEXTURE\n"
"uniform sampler2D Texture_FogHeightTexture;\n"
"#endif\n"
"uniform sampler2D Texture_FogMask;\n"
"#endif\n"
"#ifdef USELIGHTMAP\n"
"uniform sampler2D Texture_Lightmap;\n"
"#endif\n"
"#if defined(MODE_LIGHTDIRECTIONMAP_MODELSPACE) || defined(MODE_LIGHTDIRECTIONMAP_TANGENTSPACE)\n"
"uniform sampler2D Texture_Deluxemap;\n"
"#endif\n"
"#ifdef USEREFLECTION\n"
"uniform sampler2D Texture_Reflection;\n"
"#endif\n"
"\n"
"#ifdef MODE_DEFERREDLIGHTSOURCE\n"
"uniform sampler2D Texture_ScreenDepth;\n"
"uniform sampler2D Texture_ScreenNormalMap;\n"
"#endif\n"
"#ifdef USEDEFERREDLIGHTMAP\n"
"uniform sampler2D Texture_ScreenDiffuse;\n"
"uniform sampler2D Texture_ScreenSpecular;\n"
"#endif\n"
"\n"
"uniform lowp vec3 Color_Pants;\n"
"uniform lowp vec3 Color_Shirt;\n"
"uniform lowp vec3 FogColor;\n"
"\n"
"#ifdef USEFOG\n"
"uniform highp float FogRangeRecip;\n"
"uniform highp float FogPlaneViewDist;\n"
"uniform highp float FogHeightFade;\n"
"vec3 FogVertex(vec4 surfacecolor)\n"
"{\n"
"	vec3 EyeVectorModelSpace = EyeVectorModelSpaceFogPlaneVertexDist.xyz;\n"
"	float FogPlaneVertexDist = EyeVectorModelSpaceFogPlaneVertexDist.w;\n"
"	float fogfrac;\n"
"       vec3 fc = FogColor;\n"
"#ifdef USEFOGALPHAHACK\n"
"	fc *= surfacecolor.a;\n"
"#endif\n"
"#ifdef USEFOGHEIGHTTEXTURE\n"
"	vec4 fogheightpixel = texture2D(Texture_FogHeightTexture, vec2(1,1) + vec2(FogPlaneVertexDist, FogPlaneViewDist) * (-2.0 * FogHeightFade));\n"
"	fogfrac = fogheightpixel.a;\n"
"	return mix(fogheightpixel.rgb * fc, surfacecolor.rgb, texture2D(Texture_FogMask, myhalf2(length(EyeVectorModelSpace)*fogfrac*FogRangeRecip, 0.0)).r);\n"
"#else\n"
"# ifdef USEFOGOUTSIDE\n"
"	fogfrac = min(0.0, FogPlaneVertexDist) / (FogPlaneVertexDist - FogPlaneViewDist) * min(1.0, min(0.0, FogPlaneVertexDist) * FogHeightFade);\n"
"# else\n"
"	fogfrac = FogPlaneViewDist / (FogPlaneViewDist - max(0.0, FogPlaneVertexDist)) * min(1.0, (min(0.0, FogPlaneVertexDist) + FogPlaneViewDist) * FogHeightFade);\n"
"# endif\n"
"	return mix(fc, surfacecolor.rgb, texture2D(Texture_FogMask, myhalf2(length(EyeVectorModelSpace)*fogfrac*FogRangeRecip, 0.0)).r);\n"
"#endif\n"
"}\n"
"#endif\n"
"\n"
"#ifdef USEOFFSETMAPPING\n"
"uniform mediump float OffsetMapping_Scale;\n"
"vec2 OffsetMapping(vec2 TexCoord)\n"
"{\n"
"#ifdef USEOFFSETMAPPING_RELIEFMAPPING\n"
"	// 14 sample relief mapping: linear search and then binary search\n"
"	// this basically steps forward a small amount repeatedly until it finds\n"
"	// itself inside solid, then jitters forward and back using decreasing\n"
"	// amounts to find the impact\n"
"	//vec3 OffsetVector = vec3(EyeVector.xy * ((1.0 / EyeVector.z) * OffsetMapping_Scale) * vec2(-1, 1), -1);\n"
"	//vec3 OffsetVector = vec3(normalize(EyeVector.xy) * OffsetMapping_Scale * vec2(-1, 1), -1);\n"
"	vec3 OffsetVector = vec3(normalize(EyeVector).xy * OffsetMapping_Scale * vec2(-1, 1), -1);\n"
"	vec3 RT = vec3(TexCoord, 1);\n"
"	OffsetVector *= 0.1;\n"
"	RT += OffsetVector *  step(texture2D(Texture_Normal, RT.xy).a, RT.z);\n"
"	RT += OffsetVector *  step(texture2D(Texture_Normal, RT.xy).a, RT.z);\n"
"	RT += OffsetVector *  step(texture2D(Texture_Normal, RT.xy).a, RT.z);\n"
"	RT += OffsetVector *  step(texture2D(Texture_Normal, RT.xy).a, RT.z);\n"
"	RT += OffsetVector *  step(texture2D(Texture_Normal, RT.xy).a, RT.z);\n"
"	RT += OffsetVector *  step(texture2D(Texture_Normal, RT.xy).a, RT.z);\n"
"	RT += OffsetVector *  step(texture2D(Texture_Normal, RT.xy).a, RT.z);\n"
"	RT += OffsetVector *  step(texture2D(Texture_Normal, RT.xy).a, RT.z);\n"
"	RT += OffsetVector *  step(texture2D(Texture_Normal, RT.xy).a, RT.z);\n"
"	RT += OffsetVector * (step(texture2D(Texture_Normal, RT.xy).a, RT.z)          - 0.5);\n"
"	RT += OffsetVector * (step(texture2D(Texture_Normal, RT.xy).a, RT.z) * 0.5    - 0.25);\n"
"	RT += OffsetVector * (step(texture2D(Texture_Normal, RT.xy).a, RT.z) * 0.25   - 0.125);\n"
"	RT += OffsetVector * (step(texture2D(Texture_Normal, RT.xy).a, RT.z) * 0.125  - 0.0625);\n"
"	RT += OffsetVector * (step(texture2D(Texture_Normal, RT.xy).a, RT.z) * 0.0625 - 0.03125);\n"
"	return RT.xy;\n"
"#else\n"
"	// 2 sample offset mapping (only 2 samples because of ATI Radeon 9500-9800/X300 limits)\n"
"	//vec2 OffsetVector = vec2(EyeVector.xy * ((1.0 / EyeVector.z) * OffsetMapping_Scale) * vec2(-1, 1));\n"
"	//vec2 OffsetVector = vec2(normalize(EyeVector.xy) * OffsetMapping_Scale * vec2(-1, 1));\n"
"	vec2 OffsetVector = vec2(normalize(EyeVector).xy * OffsetMapping_Scale * vec2(-1, 1));\n"
"	OffsetVector *= 0.5;\n"
"	TexCoord += OffsetVector * (1.0 - texture2D(Texture_Normal, TexCoord).a);\n"
"	TexCoord += OffsetVector * (1.0 - texture2D(Texture_Normal, TexCoord).a);\n"
"	return TexCoord;\n"
"#endif\n"
"}\n"
"#endif // USEOFFSETMAPPING\n"
"\n"
"#if defined(MODE_LIGHTSOURCE) || defined(MODE_DEFERREDLIGHTSOURCE)\n"
"uniform sampler2D Texture_Attenuation;\n"
"uniform samplerCube Texture_Cube;\n"
"#endif\n"
"\n"
"#if defined(MODE_LIGHTSOURCE) || defined(MODE_DEFERREDLIGHTSOURCE) || defined(USESHADOWMAPORTHO)\n"
"\n"
"#ifdef USESHADOWMAP2D\n"
"# ifdef USESHADOWSAMPLER\n"
"uniform sampler2DShadow Texture_ShadowMap2D;\n"
"# else\n"
"uniform sampler2D Texture_ShadowMap2D;\n"
"# endif\n"
"#endif\n"
"\n"
"#ifdef USESHADOWMAPVSDCT\n"
"uniform samplerCube Texture_CubeProjection;\n"
"#endif\n"
"\n"
"#if defined(USESHADOWMAP2D)\n"
"uniform mediump vec2 ShadowMap_TextureScale;\n"
"uniform mediump vec4 ShadowMap_Parameters;\n"
"#endif\n"
"\n"
"#if defined(USESHADOWMAP2D)\n"
"# ifdef USESHADOWMAPORTHO\n"
"#  define GetShadowMapTC2D(dir) (min(dir, ShadowMap_Parameters.xyz))\n"
"# else\n"
"#  ifdef USESHADOWMAPVSDCT\n"
"vec3 GetShadowMapTC2D(vec3 dir)\n"
"{\n"
"	vec3 adir = abs(dir);\n"
"	vec2 aparams = ShadowMap_Parameters.xy / max(max(adir.x, adir.y), adir.z);\n"
"	vec4 proj = textureCube(Texture_CubeProjection, dir);\n"
"	return vec3(mix(dir.xy, dir.zz, proj.xy) * aparams.x + proj.zw * ShadowMap_Parameters.z, aparams.y + ShadowMap_Parameters.w);\n"
"}\n"
"#  else\n"
"vec3 GetShadowMapTC2D(vec3 dir)\n"
"{\n"
"	vec3 adir = abs(dir);\n"
"	float ma = adir.z;\n"
"	vec4 proj = vec4(dir, 2.5);\n"
"	if (adir.x > ma) { ma = adir.x; proj = vec4(dir.zyx, 0.5); }\n"
"	if (adir.y > ma) { ma = adir.y; proj = vec4(dir.xzy, 1.5); }\n"
"	vec2 aparams = ShadowMap_Parameters.xy / ma;\n"
"	return vec3(proj.xy * aparams.x + vec2(proj.z < 0.0 ? 1.5 : 0.5, proj.w) * ShadowMap_Parameters.z, aparams.y + ShadowMap_Parameters.w);\n"
"}\n"
"#  endif\n"
"# endif\n"
"#endif // defined(USESHADOWMAP2D)\n"
"\n"
"# ifdef USESHADOWMAP2D\n"
"float ShadowMapCompare(vec3 dir)\n"
"{\n"
"	vec3 shadowmaptc = GetShadowMapTC2D(dir);\n"
"	float f;\n"
"\n"
"#  ifdef USESHADOWSAMPLER\n"
"#    ifdef USESHADOWMAPPCF\n"
"#      define texval(x, y) shadow2D(Texture_ShadowMap2D, vec3(center + vec2(x, y)*ShadowMap_TextureScale, shadowmaptc.z)).r  \n"
"	vec2 center = shadowmaptc.xy*ShadowMap_TextureScale;\n"
"	f = dot(vec4(0.25), vec4(texval(-0.4, 1.0), texval(-1.0, -0.4), texval(0.4, -1.0), texval(1.0, 0.4)));\n"
"#    else\n"
"	f = shadow2D(Texture_ShadowMap2D, vec3(shadowmaptc.xy*ShadowMap_TextureScale, shadowmaptc.z)).r;\n"
"#    endif\n"
"#  else\n"
"#    ifdef USESHADOWMAPPCF\n"
"#     if defined(GL_ARB_texture_gather) || defined(GL_AMD_texture_texture4)\n"
"#      ifdef GL_ARB_texture_gather\n"
"#        define texval(x, y) textureGatherOffset(Texture_ShadowMap2D, center, ivec2(x, y))\n"
"#      else\n"
"#        define texval(x, y) texture4(Texture_ShadowMap2D, center + vec2(x, y)*ShadowMap_TextureScale)\n"
"#      endif\n"
"	vec2 offset = fract(shadowmaptc.xy - 0.5), center = (shadowmaptc.xy - offset)*ShadowMap_TextureScale;\n"
"#      if USESHADOWMAPPCF > 1\n"
"   vec4 group1 = step(shadowmaptc.z, texval(-2.0, -2.0));\n"
"   vec4 group2 = step(shadowmaptc.z, texval( 0.0, -2.0));\n"
"   vec4 group3 = step(shadowmaptc.z, texval( 2.0, -2.0));\n"
"   vec4 group4 = step(shadowmaptc.z, texval(-2.0,  0.0));\n"
"   vec4 group5 = step(shadowmaptc.z, texval( 0.0,  0.0));\n"
"   vec4 group6 = step(shadowmaptc.z, texval( 2.0,  0.0));\n"
"   vec4 group7 = step(shadowmaptc.z, texval(-2.0,  2.0));\n"
"   vec4 group8 = step(shadowmaptc.z, texval( 0.0,  2.0));\n"
"   vec4 group9 = step(shadowmaptc.z, texval( 2.0,  2.0));\n"
"	vec4 locols = vec4(group1.ab, group3.ab);\n"
"	vec4 hicols = vec4(group7.rg, group9.rg);\n"
"	locols.yz += group2.ab;\n"
"	hicols.yz += group8.rg;\n"
"	vec4 midcols = vec4(group1.rg, group3.rg) + vec4(group7.ab, group9.ab) +\n"
"				vec4(group4.rg, group6.rg) + vec4(group4.ab, group6.ab) +\n"
"				mix(locols, hicols, offset.y);\n"
"	vec4 cols = group5 + vec4(group2.rg, group8.ab);\n"
"	cols.xyz += mix(midcols.xyz, midcols.yzw, offset.x);\n"
"	f = dot(cols, vec4(1.0/25.0));\n"
"#      else\n"
"	vec4 group1 = step(shadowmaptc.z, texval(-1.0, -1.0));\n"
"	vec4 group2 = step(shadowmaptc.z, texval( 1.0, -1.0));\n"
"	vec4 group3 = step(shadowmaptc.z, texval(-1.0,  1.0));\n"
"	vec4 group4 = step(shadowmaptc.z, texval( 1.0,  1.0));\n"
"	vec4 cols = vec4(group1.rg, group2.rg) + vec4(group3.ab, group4.ab) +\n"
"				mix(vec4(group1.ab, group2.ab), vec4(group3.rg, group4.rg), offset.y);\n"
"	f = dot(mix(cols.xyz, cols.yzw, offset.x), vec3(1.0/9.0));\n"
"#      endif\n"
"#     else\n"
"#      ifdef GL_EXT_gpu_shader4\n"
"#        define texval(x, y) texture2DOffset(Texture_ShadowMap2D, center, ivec2(x, y)).r\n"
"#      else\n"
"#        define texval(x, y) texture2D(Texture_ShadowMap2D, center + vec2(x, y)*ShadowMap_TextureScale).r  \n"
"#      endif\n"
"#      if USESHADOWMAPPCF > 1\n"
"	vec2 center = shadowmaptc.xy - 0.5, offset = fract(center);\n"
"	center *= ShadowMap_TextureScale;\n"
"	vec4 row1 = step(shadowmaptc.z, vec4(texval(-1.0, -1.0), texval( 0.0, -1.0), texval( 1.0, -1.0), texval( 2.0, -1.0)));\n"
"	vec4 row2 = step(shadowmaptc.z, vec4(texval(-1.0,  0.0), texval( 0.0,  0.0), texval( 1.0,  0.0), texval( 2.0,  0.0)));\n"
"	vec4 row3 = step(shadowmaptc.z, vec4(texval(-1.0,  1.0), texval( 0.0,  1.0), texval( 1.0,  1.0), texval( 2.0,  1.0)));\n"
"	vec4 row4 = step(shadowmaptc.z, vec4(texval(-1.0,  2.0), texval( 0.0,  2.0), texval( 1.0,  2.0), texval( 2.0,  2.0)));\n"
"	vec4 cols = row2 + row3 + mix(row1, row4, offset.y);\n"
"	f = dot(mix(cols.xyz, cols.yzw, offset.x), vec3(1.0/9.0));\n"
"#      else\n"
"	vec2 center = shadowmaptc.xy*ShadowMap_TextureScale, offset = fract(shadowmaptc.xy);\n"
"	vec3 row1 = step(shadowmaptc.z, vec3(texval(-1.0, -1.0), texval( 0.0, -1.0), texval( 1.0, -1.0)));\n"
"	vec3 row2 = step(shadowmaptc.z, vec3(texval(-1.0,  0.0), texval( 0.0,  0.0), texval( 1.0,  0.0)));\n"
"	vec3 row3 = step(shadowmaptc.z, vec3(texval(-1.0,  1.0), texval( 0.0,  1.0), texval( 1.0,  1.0)));\n"
"	vec3 cols = row2 + mix(row1, row3, offset.y);\n"
"	f = dot(mix(cols.xy, cols.yz, offset.x), vec2(0.25));\n"
"#      endif\n"
"#     endif\n"
"#    else\n"
"	f = step(shadowmaptc.z, texture2D(Texture_ShadowMap2D, shadowmaptc.xy*ShadowMap_TextureScale).r);\n"
"#    endif\n"
"#  endif\n"
"#  ifdef USESHADOWMAPORTHO\n"
"	return mix(ShadowMap_Parameters.w, 1.0, f);\n"
"#  else\n"
"	return f;\n"
"#  endif\n"
"}\n"
"# endif\n"
"#endif // !defined(MODE_LIGHTSOURCE) && !defined(MODE_DEFERREDLIGHTSOURCE) && !defined(USESHADOWMAPORTHO)\n"
"#endif // FRAGMENT_SHADER\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_DEFERREDGEOMETRY\n"
"#ifdef VERTEX_SHADER\n"
"uniform highp mat4 TexMatrix;\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"uniform highp mat4 BackgroundTexMatrix;\n"
"#endif\n"
"uniform highp mat4 ModelViewMatrix;\n"
"void main(void)\n"
"{\n"
"	TexCoordSurfaceLightmap.xy = vec4((TexMatrix * Attrib_TexCoord0).xy, 0.0, 0.0);\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"	VertexColor = Attrib_Color;\n"
"	TexCoord2 = vec2(BackgroundTexMatrix * Attrib_TexCoord0);\n"
"#endif\n"
"\n"
"	// transform unnormalized eye direction into tangent space\n"
"#ifdef USEOFFSETMAPPING\n"
"	vec3 EyeVectorModelSpace = EyePosition - Attrib_Position.xyz;\n"
"	EyeVector.x = dot(EyeVectorModelSpace, Attrib_TexCoord1.xyz);\n"
"	EyeVector.y = dot(EyeVectorModelSpace, Attrib_TexCoord2.xyz);\n"
"	EyeVector.z = dot(EyeVectorModelSpace, Attrib_TexCoord3.xyz);\n"
"#endif\n"
"\n"
"	VectorS = (ModelViewMatrix * vec4(Attrib_TexCoord1.xyz, 0)).xyz;\n"
"	VectorT = (ModelViewMatrix * vec4(Attrib_TexCoord2.xyz, 0)).xyz;\n"
"	VectorR = (ModelViewMatrix * vec4(Attrib_TexCoord3.xyz, 0)).xyz;\n"
"	gl_Position = ModelViewProjectionMatrix * Attrib_Position;\n"
"}\n"
"#endif // VERTEX_SHADER\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"void main(void)\n"
"{\n"
"#ifdef USEOFFSETMAPPING\n"
"	// apply offsetmapping\n"
"	vec2 TexCoord = OffsetMapping(TexCoordSurfaceLightmap.xy);\n"
"#else\n"
"# define TexCoord (TexCoordSurfaceLightmap.xy)\n"
"#endif\n"
"\n"
"#ifdef USEALPHAKILL\n"
"	if (texture2D(Texture_Color, TexCoord).a < 0.5)\n"
"		discard;\n"
"#endif\n"
"\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"	float alpha = texture2D(Texture_Color, TexCoord).a;\n"
"	float terrainblend = clamp(float(VertexColor.a) * alpha * 2.0 - 0.5, float(0.0), float(1.0));\n"
"	//float terrainblend = min(float(VertexColor.a) * alpha * 2.0, float(1.0));\n"
"	//float terrainblend = float(VertexColor.a) * alpha > 0.5;\n"
"#endif\n"
"\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"	vec3 surfacenormal = mix(vec3(texture2D(Texture_SecondaryNormal, TexCoord2)), vec3(texture2D(Texture_Normal, TexCoord)), terrainblend) - vec3(0.5, 0.5, 0.5);\n"
"	float a = mix(texture2D(Texture_SecondaryGloss, TexCoord2).a, texture2D(Texture_Gloss, TexCoord).a, terrainblend);\n"
"#else\n"
"	vec3 surfacenormal = vec3(texture2D(Texture_Normal, TexCoord)) - vec3(0.5, 0.5, 0.5);\n"
"	float a = texture2D(Texture_Gloss, TexCoord).a;\n"
"#endif\n"
"\n"
"	gl_FragColor = vec4(normalize(surfacenormal.x * VectorS + surfacenormal.y * VectorT + surfacenormal.z * VectorR) * 0.5 + vec3(0.5, 0.5, 0.5), a);\n"
"}\n"
"#endif // FRAGMENT_SHADER\n"
"#else // !MODE_DEFERREDGEOMETRY\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_DEFERREDLIGHTSOURCE\n"
"#ifdef VERTEX_SHADER\n"
"uniform highp mat4 ModelViewMatrix;\n"
"void main(void)\n"
"{\n"
"	ModelViewPosition = ModelViewMatrix * Attrib_Position;\n"
"	gl_Position = ModelViewProjectionMatrix * Attrib_Position;\n"
"}\n"
"#endif // VERTEX_SHADER\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"uniform highp mat4 ViewToLight;\n"
"// ScreenToDepth = vec2(Far / (Far - Near), Far * Near / (Near - Far));\n"
"uniform highp vec2 ScreenToDepth;\n"
"uniform myhalf3 DeferredColor_Ambient;\n"
"uniform myhalf3 DeferredColor_Diffuse;\n"
"#ifdef USESPECULAR\n"
"uniform myhalf3 DeferredColor_Specular;\n"
"uniform myhalf SpecularPower;\n"
"#endif\n"
"uniform myhalf2 PixelToScreenTexCoord;\n"
"void main(void)\n"
"{\n"
"	// calculate viewspace pixel position\n"
"	vec2 ScreenTexCoord = gl_FragCoord.xy * PixelToScreenTexCoord;\n"
"	vec3 position;\n"
"	position.z = ScreenToDepth.y / (texture2D(Texture_ScreenDepth, ScreenTexCoord).r + ScreenToDepth.x);\n"
"	position.xy = ModelViewPosition.xy * (position.z / ModelViewPosition.z);\n"
"	// decode viewspace pixel normal\n"
"	myhalf4 normalmap = texture2D(Texture_ScreenNormalMap, ScreenTexCoord);\n"
"	myhalf3 surfacenormal = normalize(normalmap.rgb - myhalf3(0.5,0.5,0.5));\n"
"	// surfacenormal = pixel normal in viewspace\n"
"	// LightVector = pixel to light in viewspace\n"
"	// CubeVector = position in lightspace\n"
"	// eyevector = pixel to view in viewspace\n"
"	vec3 CubeVector = vec3(ViewToLight * vec4(position,1));\n"
"	myhalf fade = myhalf(texture2D(Texture_Attenuation, vec2(length(CubeVector), 0.0)));\n"
"#ifdef USEDIFFUSE\n"
"	// calculate diffuse shading\n"
"	myhalf3 lightnormal = myhalf3(normalize(LightPosition - position));\n"
"	myhalf diffuse = myhalf(max(float(dot(surfacenormal, lightnormal)), 0.0));\n"
"#endif\n"
"#ifdef USESPECULAR\n"
"	// calculate directional shading\n"
"	vec3 eyevector = position * -1.0;\n"
"#  ifdef USEEXACTSPECULARMATH\n"
"	myhalf specular = pow(myhalf(max(float(dot(reflect(lightnormal, surfacenormal), normalize(eyevector)))*-1.0, 0.0)), SpecularPower * normalmap.a);\n"
"#  else\n"
"	myhalf3 specularnormal = normalize(lightnormal + myhalf3(normalize(eyevector)));\n"
"	myhalf specular = pow(myhalf(max(float(dot(surfacenormal, specularnormal)), 0.0)), SpecularPower * normalmap.a);\n"
"#  endif\n"
"#endif\n"
"\n"
"#if defined(USESHADOWMAP2D)\n"
"	fade *= ShadowMapCompare(CubeVector);\n"
"#endif\n"
"\n"
"#ifdef USEDIFFUSE\n"
"	gl_FragData[0] = vec4((DeferredColor_Ambient + DeferredColor_Diffuse * diffuse) * fade, 1.0);\n"
"#else\n"
"	gl_FragData[0] = vec4(DeferredColor_Ambient * fade, 1.0);\n"
"#endif\n"
"#ifdef USESPECULAR\n"
"	gl_FragData[1] = vec4(DeferredColor_Specular * (specular * fade), 1.0);\n"
"#else\n"
"	gl_FragData[1] = vec4(0.0, 0.0, 0.0, 1.0);\n"
"#endif\n"
"\n"
"# ifdef USECUBEFILTER\n"
"	vec3 cubecolor = textureCube(Texture_Cube, CubeVector).rgb;\n"
"	gl_FragData[0].rgb *= cubecolor;\n"
"	gl_FragData[1].rgb *= cubecolor;\n"
"# endif\n"
"}\n"
"#endif // FRAGMENT_SHADER\n"
"#else // !MODE_DEFERREDLIGHTSOURCE\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef VERTEX_SHADER\n"
"uniform highp mat4 TexMatrix;\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"uniform highp mat4 BackgroundTexMatrix;\n"
"#endif\n"
"#ifdef MODE_LIGHTSOURCE\n"
"uniform highp mat4 ModelToLight;\n"
"#endif\n"
"#ifdef USESHADOWMAPORTHO\n"
"uniform highp mat4 ShadowMapMatrix;\n"
"#endif\n"
"#ifdef USEBOUNCEGRID\n"
"uniform highp mat4 BounceGridMatrix;\n"
"#endif\n"
"void main(void)\n"
"{\n"
"#if defined(MODE_VERTEXCOLOR) || defined(USEVERTEXTEXTUREBLEND)\n"
"	VertexColor = Attrib_Color;\n"
"#endif\n"
"	// copy the surface texcoord\n"
"#ifdef USELIGHTMAP\n"
"	TexCoordSurfaceLightmap = vec4((TexMatrix * Attrib_TexCoord0).xy, Attrib_TexCoord4.xy);\n"
"#else\n"
"	TexCoordSurfaceLightmap = vec4((TexMatrix * Attrib_TexCoord0).xy, 0.0, 0.0);\n"
"#endif\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"	TexCoord2 = vec2(BackgroundTexMatrix * Attrib_TexCoord0);\n"
"#endif\n"
"\n"
"#ifdef USEBOUNCEGRID\n"
"	BounceGridTexCoord = vec3(BounceGridMatrix * Attrib_Position);\n"
"#endif\n"
"\n"
"#ifdef MODE_LIGHTSOURCE\n"
"	// transform vertex position into light attenuation/cubemap space\n"
"	// (-1 to +1 across the light box)\n"
"	CubeVector = vec3(ModelToLight * Attrib_Position);\n"
"\n"
"# ifdef USEDIFFUSE\n"
"	// transform unnormalized light direction into tangent space\n"
"	// (we use unnormalized to ensure that it interpolates correctly and then\n"
"	//  normalize it per pixel)\n"
"	vec3 lightminusvertex = LightPosition - Attrib_Position.xyz;\n"
"	LightVector.x = dot(lightminusvertex, Attrib_TexCoord1.xyz);\n"
"	LightVector.y = dot(lightminusvertex, Attrib_TexCoord2.xyz);\n"
"	LightVector.z = dot(lightminusvertex, Attrib_TexCoord3.xyz);\n"
"# endif\n"
"#endif\n"
"\n"
"#if defined(MODE_LIGHTDIRECTION) && defined(USEDIFFUSE)\n"
"	LightVector.x = dot(LightDir, Attrib_TexCoord1.xyz);\n"
"	LightVector.y = dot(LightDir, Attrib_TexCoord2.xyz);\n"
"	LightVector.z = dot(LightDir, Attrib_TexCoord3.xyz);\n"
"#endif\n"
"\n"
"	// transform unnormalized eye direction into tangent space\n"
"#ifdef USEEYEVECTOR\n"
"	vec3 EyeVectorModelSpace = EyePosition - Attrib_Position.xyz;\n"
"	EyeVector.x = dot(EyeVectorModelSpace, Attrib_TexCoord1.xyz);\n"
"	EyeVector.y = dot(EyeVectorModelSpace, Attrib_TexCoord2.xyz);\n"
"	EyeVector.z = dot(EyeVectorModelSpace, Attrib_TexCoord3.xyz);\n"
"#endif\n"
"\n"
"#ifdef USEFOG\n"
"	EyeVectorModelSpaceFogPlaneVertexDist.xyz = EyePosition - Attrib_Position.xyz;\n"
"	EyeVectorModelSpaceFogPlaneVertexDist.w = dot(FogPlane, Attrib_Position);\n"
"#endif\n"
"\n"
"#if defined(MODE_LIGHTDIRECTIONMAP_MODELSPACE) || defined(USEREFLECTCUBE)\n"
"	VectorS = Attrib_TexCoord1.xyz;\n"
"	VectorT = Attrib_TexCoord2.xyz;\n"
"	VectorR = Attrib_TexCoord3.xyz;\n"
"#endif\n"
"\n"
"	// transform vertex to camera space, using ftransform to match non-VS rendering\n"
"	gl_Position = ModelViewProjectionMatrix * Attrib_Position;\n"
"\n"
"#ifdef USESHADOWMAPORTHO\n"
"	ShadowMapTC = vec3(ShadowMapMatrix * gl_Position);\n"
"#endif\n"
"\n"
"#ifdef USEREFLECTION\n"
"	ModelViewProjectionPosition = gl_Position;\n"
"#endif\n"
"}\n"
"#endif // VERTEX_SHADER\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef FRAGMENT_SHADER\n"
"#ifdef USEDEFERREDLIGHTMAP\n"
"uniform myhalf2 PixelToScreenTexCoord;\n"
"uniform myhalf3 DeferredMod_Diffuse;\n"
"uniform myhalf3 DeferredMod_Specular;\n"
"#endif\n"
"uniform myhalf3 Color_Ambient;\n"
"uniform myhalf3 Color_Diffuse;\n"
"uniform myhalf3 Color_Specular;\n"
"uniform myhalf SpecularPower;\n"
"#ifdef USEGLOW\n"
"uniform myhalf3 Color_Glow;\n"
"#endif\n"
"uniform myhalf Alpha;\n"
"#ifdef USEREFLECTION\n"
"uniform mediump vec4 DistortScaleRefractReflect;\n"
"uniform mediump vec4 ScreenScaleRefractReflect;\n"
"uniform mediump vec4 ScreenCenterRefractReflect;\n"
"uniform lowp vec4 ReflectColor;\n"
"#endif\n"
"#ifdef USEREFLECTCUBE\n"
"uniform highp mat4 ModelToReflectCube;\n"
"uniform sampler2D Texture_ReflectMask;\n"
"uniform samplerCube Texture_ReflectCube;\n"
"#endif\n"
"#ifdef MODE_LIGHTDIRECTION\n"
"uniform myhalf3 LightColor;\n"
"#endif\n"
"#ifdef MODE_LIGHTSOURCE\n"
"uniform myhalf3 LightColor;\n"
"#endif\n"
"#ifdef USEBOUNCEGRID\n"
"uniform sampler3D Texture_BounceGrid;\n"
"uniform float BounceGridIntensity;\n"
"#endif\n"
"void main(void)\n"
"{\n"
"#ifdef USEOFFSETMAPPING\n"
"	// apply offsetmapping\n"
"	vec2 TexCoord = OffsetMapping(TexCoordSurfaceLightmap.xy);\n"
"#else\n"
"# define TexCoord (TexCoordSurfaceLightmap.xy)\n"
"#endif\n"
"\n"
"	// combine the diffuse textures (base, pants, shirt)\n"
"	myhalf4 color = myhalf4(texture2D(Texture_Color, TexCoord));\n"
"#ifdef USEALPHAKILL\n"
"	if (color.a < 0.5)\n"
"		discard;\n"
"#endif\n"
"	color.a *= Alpha;\n"
"#ifdef USECOLORMAPPING\n"
"	color.rgb += myhalf3(texture2D(Texture_Pants, TexCoord)) * Color_Pants + myhalf3(texture2D(Texture_Shirt, TexCoord)) * Color_Shirt;\n"
"#endif\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"	myhalf terrainblend = clamp(myhalf(VertexColor.a) * color.a * 2.0 - 0.5, myhalf(0.0), myhalf(1.0));\n"
"	//myhalf terrainblend = min(myhalf(VertexColor.a) * color.a * 2.0, myhalf(1.0));\n"
"	//myhalf terrainblend = myhalf(VertexColor.a) * color.a > 0.5;\n"
"	color.rgb = mix(myhalf3(texture2D(Texture_SecondaryColor, TexCoord2)), color.rgb, terrainblend);\n"
"	color.a = 1.0;\n"
"	//color = mix(myhalf4(1, 0, 0, 1), color, terrainblend);\n"
"#endif\n"
"\n"
"	// get the surface normal\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"	myhalf3 surfacenormal = normalize(mix(myhalf3(texture2D(Texture_SecondaryNormal, TexCoord2)), myhalf3(texture2D(Texture_Normal, TexCoord)), terrainblend) - myhalf3(0.5, 0.5, 0.5));\n"
"#else\n"
"	myhalf3 surfacenormal = normalize(myhalf3(texture2D(Texture_Normal, TexCoord)) - myhalf3(0.5, 0.5, 0.5));\n"
"#endif\n"
"\n"
"	// get the material colors\n"
"	myhalf3 diffusetex = color.rgb;\n"
"#if defined(USESPECULAR) || defined(USEDEFERREDLIGHTMAP)\n"
"# ifdef USEVERTEXTEXTUREBLEND\n"
"	myhalf4 glosstex = mix(myhalf4(texture2D(Texture_SecondaryGloss, TexCoord2)), myhalf4(texture2D(Texture_Gloss, TexCoord)), terrainblend);\n"
"# else\n"
"	myhalf4 glosstex = myhalf4(texture2D(Texture_Gloss, TexCoord));\n"
"# endif\n"
"#endif\n"
"\n"
"#ifdef USEREFLECTCUBE\n"
"	vec3 TangentReflectVector = reflect(-EyeVector, surfacenormal);\n"
"	vec3 ModelReflectVector = TangentReflectVector.x * VectorS + TangentReflectVector.y * VectorT + TangentReflectVector.z * VectorR;\n"
"	vec3 ReflectCubeTexCoord = vec3(ModelToReflectCube * vec4(ModelReflectVector, 0));\n"
"	diffusetex += myhalf3(texture2D(Texture_ReflectMask, TexCoord)) * myhalf3(textureCube(Texture_ReflectCube, ReflectCubeTexCoord));\n"
"#endif\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_LIGHTSOURCE\n"
"	// light source\n"
"#ifdef USEDIFFUSE\n"
"	myhalf3 lightnormal = myhalf3(normalize(LightVector));\n"
"	myhalf diffuse = myhalf(max(float(dot(surfacenormal, lightnormal)), 0.0));\n"
"	color.rgb = diffusetex * (Color_Ambient + diffuse * Color_Diffuse);\n"
"#ifdef USESPECULAR\n"
"#ifdef USEEXACTSPECULARMATH\n"
"	myhalf specular = pow(myhalf(max(float(dot(reflect(lightnormal, surfacenormal), normalize(EyeVector)))*-1.0, 0.0)), SpecularPower * glosstex.a);\n"
"#else\n"
"	myhalf3 specularnormal = normalize(lightnormal + myhalf3(normalize(EyeVector)));\n"
"	myhalf specular = pow(myhalf(max(float(dot(surfacenormal, specularnormal)), 0.0)), SpecularPower * glosstex.a);\n"
"#endif\n"
"	color.rgb += glosstex.rgb * (specular * Color_Specular);\n"
"#endif\n"
"#else\n"
"	color.rgb = diffusetex * Color_Ambient;\n"
"#endif\n"
"	color.rgb *= LightColor;\n"
"	color.rgb *= myhalf(texture2D(Texture_Attenuation, vec2(length(CubeVector), 0.0)));\n"
"#if defined(USESHADOWMAP2D)\n"
"	color.rgb *= ShadowMapCompare(CubeVector);\n"
"#endif\n"
"# ifdef USECUBEFILTER\n"
"	color.rgb *= myhalf3(textureCube(Texture_Cube, CubeVector));\n"
"# endif\n"
"#endif // MODE_LIGHTSOURCE\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_LIGHTDIRECTION\n"
"#define SHADING\n"
"#ifdef USEDIFFUSE\n"
"	myhalf3 lightnormal = myhalf3(normalize(LightVector));\n"
"#endif\n"
"#define lightcolor LightColor\n"
"#endif // MODE_LIGHTDIRECTION\n"
"#ifdef MODE_LIGHTDIRECTIONMAP_MODELSPACE\n"
"#define SHADING\n"
"	// deluxemap lightmapping using light vectors in modelspace (q3map2 -light -deluxe)\n"
"	myhalf3 lightnormal_modelspace = myhalf3(texture2D(Texture_Deluxemap, TexCoordSurfaceLightmap.zw)) * 2.0 + myhalf3(-1.0, -1.0, -1.0);\n"
"	myhalf3 lightcolor = myhalf3(texture2D(Texture_Lightmap, TexCoordSurfaceLightmap.zw));\n"
"	// convert modelspace light vector to tangentspace\n"
"	myhalf3 lightnormal;\n"
"	lightnormal.x = dot(lightnormal_modelspace, myhalf3(VectorS));\n"
"	lightnormal.y = dot(lightnormal_modelspace, myhalf3(VectorT));\n"
"	lightnormal.z = dot(lightnormal_modelspace, myhalf3(VectorR));\n"
"	lightnormal = normalize(lightnormal); // VectorS/T/R are not always perfectly normalized, and EXACTSPECULARMATH is very picky about this\n"
"	// calculate directional shading (and undoing the existing angle attenuation on the lightmap by the division)\n"
"	// note that q3map2 is too stupid to calculate proper surface normals when q3map_nonplanar\n"
"	// is used (the lightmap and deluxemap coords correspond to virtually random coordinates\n"
"	// on that luxel, and NOT to its center, because recursive triangle subdivision is used\n"
"	// to map the luxels to coordinates on the draw surfaces), which also causes\n"
"	// deluxemaps to be wrong because light contributions from the wrong side of the surface\n"
"	// are added up. To prevent divisions by zero or strong exaggerations, a max()\n"
"	// nudge is done here at expense of some additional fps. This is ONLY needed for\n"
"	// deluxemaps, tangentspace deluxemap avoid this problem by design.\n"
"	lightcolor *= 1.0 / max(0.25, lightnormal.z);\n"
"#endif // MODE_LIGHTDIRECTIONMAP_MODELSPACE\n"
"#ifdef MODE_LIGHTDIRECTIONMAP_TANGENTSPACE\n"
"#define SHADING\n"
"	// deluxemap lightmapping using light vectors in tangentspace (hmap2 -light)\n"
"	myhalf3 lightnormal = myhalf3(texture2D(Texture_Deluxemap, TexCoordSurfaceLightmap.zw)) * 2.0 + myhalf3(-1.0, -1.0, -1.0);\n"
"	myhalf3 lightcolor = myhalf3(texture2D(Texture_Lightmap, TexCoordSurfaceLightmap.zw));\n"
"#endif\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_FAKELIGHT\n"
"#define SHADING\n"
"myhalf3 lightnormal = myhalf3(normalize(EyeVector));\n"
"myhalf3 lightcolor = myhalf3(1.0);\n"
"#endif // MODE_FAKELIGHT\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef MODE_LIGHTMAP\n"
"	color.rgb = diffusetex * (Color_Ambient + myhalf3(texture2D(Texture_Lightmap, TexCoordSurfaceLightmap.zw)) * Color_Diffuse);\n"
"#endif // MODE_LIGHTMAP\n"
"#ifdef MODE_VERTEXCOLOR\n"
"	color.rgb = diffusetex * (Color_Ambient + myhalf3(VertexColor.rgb) * Color_Diffuse);\n"
"#endif // MODE_VERTEXCOLOR\n"
"#ifdef MODE_FLATCOLOR\n"
"	color.rgb = diffusetex * Color_Ambient;\n"
"#endif // MODE_FLATCOLOR\n"
"\n"
"\n"
"\n"
"\n"
"#ifdef SHADING\n"
"# ifdef USEDIFFUSE\n"
"	myhalf diffuse = myhalf(max(float(dot(surfacenormal, lightnormal)), 0.0));\n"
"#  ifdef USESPECULAR\n"
"#   ifdef USEEXACTSPECULARMATH\n"
"	myhalf specular = pow(myhalf(max(float(dot(reflect(lightnormal, surfacenormal), normalize(EyeVector)))*-1.0, 0.0)), SpecularPower * glosstex.a);\n"
"#   else\n"
"	myhalf3 specularnormal = normalize(lightnormal + myhalf3(normalize(EyeVector)));\n"
"	myhalf specular = pow(myhalf(max(float(dot(surfacenormal, specularnormal)), 0.0)), SpecularPower * glosstex.a);\n"
"#   endif\n"
"	color.rgb = diffusetex * Color_Ambient + (diffusetex * Color_Diffuse * diffuse + glosstex.rgb * Color_Specular * specular) * lightcolor;\n"
"#  else\n"
"	color.rgb = diffusetex * (Color_Ambient + Color_Diffuse * diffuse * lightcolor);\n"
"#  endif\n"
"# else\n"
"	color.rgb = diffusetex * Color_Ambient;\n"
"# endif\n"
"#endif\n"
"\n"
"#ifdef USESHADOWMAPORTHO\n"
"	color.rgb *= ShadowMapCompare(ShadowMapTC);\n"
"#endif\n"
"\n"
"#ifdef USEDEFERREDLIGHTMAP\n"
"	vec2 ScreenTexCoord = gl_FragCoord.xy * PixelToScreenTexCoord;\n"
"	color.rgb += diffusetex * myhalf3(texture2D(Texture_ScreenDiffuse, ScreenTexCoord)) * DeferredMod_Diffuse;\n"
"	color.rgb += glosstex.rgb * myhalf3(texture2D(Texture_ScreenSpecular, ScreenTexCoord)) * DeferredMod_Specular;\n"
"#endif\n"
"\n"
"#ifdef USEBOUNCEGRID\n"
"	color.rgb += diffusetex * myhalf3(texture3D(Texture_BounceGrid, BounceGridTexCoord)) * BounceGridIntensity;\n"
"#endif\n"
"\n"
"#ifdef USEGLOW\n"
"#ifdef USEVERTEXTEXTUREBLEND\n"
"	color.rgb += mix(myhalf3(texture2D(Texture_SecondaryGlow, TexCoord2)), myhalf3(texture2D(Texture_Glow, TexCoord)), terrainblend) * Color_Glow;\n"
"#else\n"
"	color.rgb += myhalf3(texture2D(Texture_Glow, TexCoord)) * Color_Glow;\n"
"#endif\n"
"#endif\n"
"\n"
"#ifdef USEFOG\n"
"	color.rgb = FogVertex(color);\n"
"#endif\n"
"\n"
"	// reflection must come last because it already contains exactly the correct fog (the reflection render preserves camera distance from the plane, it only flips the side) and ContrastBoost/SceneBrightness\n"
"#ifdef USEREFLECTION\n"
"	vec4 ScreenScaleRefractReflectIW = ScreenScaleRefractReflect * (1.0 / ModelViewProjectionPosition.w);\n"
"	//vec4 ScreenTexCoord = (ModelViewProjectionPosition.xyxy + normalize(myhalf3(texture2D(Texture_Normal, TexCoord)) - myhalf3(0.5)).xyxy * DistortScaleRefractReflect * 100) * ScreenScaleRefractReflectIW + ScreenCenterRefractReflect;\n"
"	vec2 SafeScreenTexCoord = ModelViewProjectionPosition.xy * ScreenScaleRefractReflectIW.zw + ScreenCenterRefractReflect.zw;\n"
"	vec2 ScreenTexCoord = SafeScreenTexCoord + vec3(normalize(myhalf3(texture2D(Texture_Normal, TexCoord)) - myhalf3(0.5))).xy * DistortScaleRefractReflect.zw;\n"
"	// FIXME temporary hack to detect the case that the reflection\n"
"	// gets blackened at edges due to leaving the area that contains actual\n"
"	// content.\n"
"	// Remove this 'ack once we have a better way to stop this thing from\n"
"	// 'appening.\n"
"	float f = min(1.0, length(texture2D(Texture_Reflection, ScreenTexCoord + vec2(0.01, 0.01)).rgb) / 0.05);\n"
"	f      *= min(1.0, length(texture2D(Texture_Reflection, ScreenTexCoord + vec2(0.01, -0.01)).rgb) / 0.05);\n"
"	f      *= min(1.0, length(texture2D(Texture_Reflection, ScreenTexCoord + vec2(-0.01, 0.01)).rgb) / 0.05);\n"
"	f      *= min(1.0, length(texture2D(Texture_Reflection, ScreenTexCoord + vec2(-0.01, -0.01)).rgb) / 0.05);\n"
"	ScreenTexCoord = mix(SafeScreenTexCoord, ScreenTexCoord, f);\n"
"	color.rgb = mix(color.rgb, myhalf3(texture2D(Texture_Reflection, ScreenTexCoord)) * ReflectColor.rgb, ReflectColor.a);\n"
"#endif\n"
"\n"
"	gl_FragColor = vec4(color);\n"
"}\n"
"#endif // FRAGMENT_SHADER\n"
"\n"
"#endif // !MODE_DEFERREDLIGHTSOURCE\n"
"#endif // !MODE_DEFERREDGEOMETRY\n"
"#endif // !MODE_WATER\n"
"#endif // !MODE_REFRACTION\n"
"#endif // !MODE_BLOOMBLUR\n"
"#endif // !MODE_GENERIC\n"
"#endif // !MODE_POSTPROCESS\n"
"#endif // !MODE_SHOWDEPTH\n"
"#endif // !MODE_DEPTH_OR_SHADOW\n"
