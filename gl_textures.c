#include "quakedef.h"

cvar_t	r_max_size = {0, "r_max_size", "2048"};
cvar_t	r_picmip = {0, "r_picmip", "0"};
cvar_t	r_lerpimages = {CVAR_SAVE, "r_lerpimages", "1"};
cvar_t	r_precachetextures = {CVAR_SAVE, "r_precachetextures", "1"};

int		gl_filter_min = GL_LINEAR_MIPMAP_LINEAR; //NEAREST;
int		gl_filter_mag = GL_LINEAR;


static mempool_t *texturemempool;

// note: this must not conflict with TEXF_ flags in r_textures.h
// cleared when a texture is uploaded
#define GLTEXF_UPLOAD 0x00010000
// texture generated by code, also causes permanent GLTEXF_UPLOAD effect
#define GLTEXF_PROCEDURAL 0x00020000
// bitmask for mismatch checking
#define GLTEXF_IMPORTANTBITS (GLTEXF_PROCEDURAL)
// set when image is uploaded and freed
#define GLTEXF_DESTROYED 0x00040000

// size of images which hold fragment textures, ignores picmip and max_size
#define BLOCK_SIZE 256

// really this number only governs gltexnuminuse
#define MAX_GLTEXTURES 65536

// since there is only one set of GL texture numbers, we have to track them
// globally, everything else is per texture pool
static byte *gltexnuminuse;

typedef struct
{
	int textype;
	int inputbytesperpixel;
	int internalbytesperpixel;
	int glformat;
	int glinternalformat;
	int align;
}
textypeinfo_t;

static textypeinfo_t textype_qpalette       = {TEXTYPE_QPALETTE, 1, 4, GL_RGBA, 3, 1};
static textypeinfo_t textype_rgb            = {TEXTYPE_RGB     , 3, 3, GL_RGB , 3, 3};
static textypeinfo_t textype_rgba           = {TEXTYPE_RGBA    , 4, 4, GL_RGBA, 3, 1};
static textypeinfo_t textype_qpalette_alpha = {TEXTYPE_QPALETTE, 1, 4, GL_RGBA, 4, 1};
static textypeinfo_t textype_rgba_alpha     = {TEXTYPE_RGBA    , 4, 4, GL_RGBA, 4, 1};

// a tiling texture (most common type)
#define GLIMAGETYPE_TILE 0
// a fragments texture (contains one or more fragment textures)
#define GLIMAGETYPE_FRAGMENTS 1

// a gltextureimage can have one (or more if fragments) gltextures inside
typedef struct gltextureimage_s
{
	struct gltextureimage_s *imagechain;
	int texturecount;
	int type; // one of the GLIMAGETYPE_ values
	int texnum; // GL texture slot number
	int width, height;
	int bytesperpixel; // bytes per pixel
	int glformat; // GL_RGB or GL_RGBA
	int glinternalformat; // 3 or 4
	int flags;
	short *blockallocation; // fragment allocation
}
gltextureimage_t;

typedef struct gltexture_s
{
	// pointer to texturepool (check this to see if the texture is allocated)
	struct gltexturepool_s *pool;
	// pointer to next texture in texturepool chain
	struct gltexture_s *chain;
	// pointer into gltextureimage array
	gltextureimage_t *image;
	// name of the texture (this might be removed someday), no duplicates
	char *identifier;
	// location in the image, and size
	int x, y, width, height;
	// copy of the original texture supplied to the upload function, for re-uploading or deferred uploads (non-precached)
	byte *inputtexels;
	// to identify cache mismatchs (this might be removed someday)
	int crc;
	// flags supplied to the LoadTexture/ProceduralTexture functions
	// (might be altered to remove TEXF_ALPHA), and GLTEXF_ private flags
	int flags;
	// procedural texture generation function, called once per frame if the texture is used
	int (*generate)(byte *buffer, int width, int height, void *parameterdata, int parameterdatasize);
	// data provided to generate, persistent from call to call
	byte *proceduraldata;
	// size of data
	int proceduraldatasize;
	// used only to avoid updating the texture more than once per frame
	int proceduralframecount;
	// pointer to one of the textype_ structs
	textypeinfo_t *textype;
}
gltexture_t;

#define TEXTUREPOOL_SENTINEL 0xC0DEDBAD

typedef struct gltexturepool_s
{
	int sentinel;
	struct gltextureimage_s *imagechain;
	struct gltexture_s *gltchain;
	struct gltexturepool_s *next;
}
gltexturepool_t;

static gltexturepool_t *gltexturepoolchain = NULL;

static byte *resamplerow1 = NULL, *resamplerow2 = NULL;
static int resamplerowsize = 0;
static byte *resizebuffer = NULL, *colorconvertbuffer;
static int resizebuffersize = 0;
static byte *texturebuffer;
static int texturebuffersize = 0;

static int realmaxsize = 0;

static textypeinfo_t *R_GetTexTypeInfo(int textype, int flags)
{
	if (flags & TEXF_ALPHA)
	{
		switch(textype)
		{
		case TEXTYPE_QPALETTE:
			return &textype_qpalette_alpha;
		case TEXTYPE_RGB:
			Host_Error("R_GetTexTypeInfo: RGB format has no alpha, TEXF_ALPHA not allowed\n");
			return NULL;
		case TEXTYPE_RGBA:
			return &textype_rgba_alpha;
		default:
			Host_Error("R_GetTexTypeInfo: unknown texture format\n");
			return NULL;
		}
	}
	else
	{
		switch(textype)
		{
		case TEXTYPE_QPALETTE:
			return &textype_qpalette;
		case TEXTYPE_RGB:
			return &textype_rgb;
		case TEXTYPE_RGBA:
			return &textype_rgba;
		default:
			Host_Error("R_GetTexTypeInfo: unknown texture format\n");
			return NULL;
		}
	}
}

static void R_UploadTexture(gltexture_t *t);

static void R_PrecacheTexture(gltexture_t *glt)
{
	int precache;
	precache = false;
	if (glt->flags & TEXF_ALWAYSPRECACHE)
		precache = true;
	else if (r_precachetextures.integer >= 2)
		precache = true;
	else if (r_precachetextures.integer >= 1)
		if (glt->flags & TEXF_PRECACHE)
			precache = true;

	if (precache)
		R_UploadTexture(glt);
}

int R_GetTexture(rtexture_t *rt)
{
	gltexture_t *glt;
	if (!rt)
		return 0;
	glt = (gltexture_t *)rt;
	if (glt->flags & (GLTEXF_UPLOAD | GLTEXF_PROCEDURAL))
	{
		if (glt->flags & GLTEXF_PROCEDURAL)
		{
			if (glt->proceduralframecount != r_framecount)
			{
				glt->proceduralframecount = r_framecount;
				R_UploadTexture(glt);
			}
		}
		else
			R_UploadTexture(glt);
	}
	return glt->image->texnum;
}

static void R_FreeTexture(gltexture_t *glt)
{
	gltexture_t **gltpointer;
	gltextureimage_t *image, **gltimagepointer;
	GLuint texnum;

	for (gltpointer = &glt->pool->gltchain;*gltpointer && *gltpointer != glt;gltpointer = &(*gltpointer)->chain);
	if (*gltpointer == glt)
		*gltpointer = glt->chain;
	else
		Host_Error("R_FreeTexture: texture not linked in pool\n");

	// note: if freeing a fragment texture, this will not make the claimed
	// space available for new textures unless all other fragments in the
	// image are also freed
	image = glt->image;
	image->texturecount--;
	if (image->texturecount < 1)
	{
		for (gltimagepointer = &glt->pool->imagechain;*gltimagepointer && *gltimagepointer != image;gltimagepointer = &(*gltimagepointer)->imagechain);
		if (*gltimagepointer == image)
			*gltimagepointer = image->imagechain;
		else
			Host_Error("R_FreeTexture: image not linked in pool\n");
		if (image->texnum)
		{
			texnum = image->texnum;
			gltexnuminuse[image->texnum] = 0;
			glDeleteTextures(1, &texnum);
		}
		if (image->blockallocation)
			Mem_Free(image->blockallocation);
		Mem_Free(image);
	}

	if (glt->identifier)
		Mem_Free(glt->identifier);
	if (glt->inputtexels)
		Mem_Free(glt->inputtexels);
	if (glt->proceduraldata)
		Mem_Free(glt->proceduraldata);
	Mem_Free(glt);
}

static gltexture_t *R_FindTexture (gltexturepool_t *pool, char *identifier)
{
	gltexture_t	*glt;

	if (!identifier)
		return NULL;

	for (glt = pool->gltchain;glt;glt = glt->chain)
		if (glt->identifier && !strcmp (identifier, glt->identifier))
			return glt;

	return NULL;
}

rtexturepool_t *R_AllocTexturePool(void)
{
	gltexturepool_t *pool;
	pool = Mem_Alloc(texturemempool, sizeof(gltexturepool_t));
	if (pool == NULL)
		return NULL;
	//memset(pool, 0, sizeof(gltexturepool_t));
	pool->next = gltexturepoolchain;
	gltexturepoolchain = pool;
	pool->sentinel = TEXTUREPOOL_SENTINEL;
	return (rtexturepool_t *)pool;
}

void R_FreeTexturePool(rtexturepool_t **rtexturepool)
{
	gltexturepool_t *pool, **poolpointer;
	if (rtexturepool == NULL)
		return;
	if (*rtexturepool == NULL)
		return;
	pool = (gltexturepool_t *)(*rtexturepool);
	*rtexturepool = NULL;
	if (pool->sentinel != TEXTUREPOOL_SENTINEL)
		Host_Error("R_FreeTexturePool: pool already freed\n");
	for (poolpointer = &gltexturepoolchain;*poolpointer && *poolpointer != pool;poolpointer = &(*poolpointer)->next);
	if (*poolpointer == pool)
		*poolpointer = pool->next;
	else
		Host_Error("R_FreeTexturePool: pool not linked\n");
	while (pool->gltchain)
		R_FreeTexture(pool->gltchain);
	Mem_Free(pool);
}


typedef struct
{
	char *name;
	int minification, magnification;
}
glmode_t;

static glmode_t modes[] =
{
	{"GL_NEAREST", GL_NEAREST, GL_NEAREST},
	{"GL_LINEAR", GL_LINEAR, GL_LINEAR},
	{"GL_NEAREST_MIPMAP_NEAREST", GL_NEAREST_MIPMAP_NEAREST, GL_NEAREST},
	{"GL_LINEAR_MIPMAP_NEAREST", GL_LINEAR_MIPMAP_NEAREST, GL_LINEAR},
	{"GL_NEAREST_MIPMAP_LINEAR", GL_NEAREST_MIPMAP_LINEAR, GL_NEAREST},
	{"GL_LINEAR_MIPMAP_LINEAR", GL_LINEAR_MIPMAP_LINEAR, GL_LINEAR}
};

static void GL_TextureMode_f (void)
{
	int i;
	gltextureimage_t *image;
	gltexturepool_t *pool;

	if (Cmd_Argc() == 1)
	{
		for (i = 0;i < 6;i++)
		{
			if (gl_filter_min == modes[i].minification)
			{
				Con_Printf ("%s\n", modes[i].name);
				return;
			}
		}
		Con_Printf ("current filter is unknown???\n");
		return;
	}

	for (i = 0;i < 6;i++)
		if (!Q_strcasecmp (modes[i].name, Cmd_Argv(1) ) )
			break;
	if (i == 6)
	{
		Con_Printf ("bad filter name\n");
		return;
	}

	gl_filter_min = modes[i].minification;
	gl_filter_mag = modes[i].magnification;

	// change all the existing mipmap texture objects
	// FIXME: force renderer(/client/something?) restart instead?
	for (pool = gltexturepoolchain;pool;pool = pool->next)
	{
		for (image = pool->imagechain;image;image = image->imagechain)
		{
			// only update already uploaded images
			if (!(image->flags & GLTEXF_UPLOAD))
			{
				glBindTexture(GL_TEXTURE_2D, image->texnum);
				if (image->flags & TEXF_MIPMAP)
					glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
				else
					glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_mag);
				glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_mag);
			}
		}
	}
}

static int R_CalcTexelDataSize (gltexture_t *glt)
{
	int width2, height2, size;
	if (glt->flags & TEXF_FRAGMENT)
		size = glt->width * glt->height;
	else
	{
		if (r_max_size.integer > realmaxsize)
			Cvar_SetValue("r_max_size", realmaxsize);
		// calculate final size
		width2 = 1;while (width2 < glt->width) width2 <<= 1;
		height2 = 1;while (height2 < glt->height) height2 <<= 1;
		width2 >>= (int) r_picmip.integer;
		height2 >>= (int) r_picmip.integer;
		while (width2 > (int) r_max_size.integer) width2 >>= 1;
		while (height2 > (int) r_max_size.integer) height2 >>= 1;
		if (width2 < 1) width2 = 1;
		if (height2 < 1) height2 = 1;

		size = 0;
		if (glt->flags & TEXF_MIPMAP)
		{
			while (width2 > 1 || height2 > 1)
			{
				size += width2 * height2;
				if (width2 > 1)
					width2 >>= 1;
				if (height2 > 1)
					height2 >>= 1;
			}
			size++; // count the last 1x1 mipmap
		}
		else
			size = width2*height2;
	}
	size *= glt->textype->internalbytesperpixel;

	return size;
}

void R_TextureStats_PrintTotal(void)
{
	int glsize, inputsize, total = 0, totalt = 0, totalp = 0, loaded = 0, loadedt = 0, loadedp = 0;
	gltexture_t *glt;
	gltexturepool_t *pool;
	for (pool = gltexturepoolchain;pool;pool = pool->next)
	{
		for (glt = pool->gltchain;glt;glt = glt->chain)
		{
			glsize = R_CalcTexelDataSize(glt);
			inputsize = glt->width * glt->height * glt->textype->inputbytesperpixel;

			total++;
			totalt += glsize;
			totalp += inputsize;
			if (!(glt->flags & GLTEXF_UPLOAD))
			{
				loaded++;
				loadedt += glsize;
				loadedp += inputsize;
			}
		}
	}
	Con_Printf("total: %i (%.3fMB, %.3fMB original), uploaded %i (%.3fMB, %.3fMB original), upload on demand %i (%.3fMB, %.3fMB original)\n", total, totalt / 1048576.0, totalp / 1048576.0, loaded, loadedt / 1048576.0, loadedp / 1048576.0, total - loaded, (totalt - loadedt) / 1048576.0, (totalp - loadedp) / 1048576.0);
}

static void R_TextureStats_f(void)
{
	int loaded;
	gltexture_t *glt;
	gltexturepool_t *pool;
	Con_Printf("glsize input crc  loaded mip alpha name\n");
	for (pool = gltexturepoolchain;pool;pool = pool->next)
	{
		for (glt = pool->gltchain;glt;glt = glt->chain)
		{
			loaded = !(glt->flags & GLTEXF_UPLOAD);
			if (glt->flags & GLTEXF_PROCEDURAL)
				Con_Printf("%c%4i%c %4i  PROC %s %s %s %s\n"  , loaded ? '[' : ' ', (R_CalcTexelDataSize(glt) + 1023) / 1024, loaded ? ']' : ' ',                               (glt->width * glt->height * glt->textype->inputbytesperpixel + 1023) / 1024,                                         loaded ? "loaded" : "      ", (glt->flags & TEXF_MIPMAP) ? "mip" : "   ", (glt->flags & TEXF_ALPHA) ? "alpha" : "     ", glt->identifier ? glt->identifier : "<unnamed>");
			else
				Con_Printf("%c%4i%c%c%4i%c %04X %s %s %s %s\n", loaded ? '[' : ' ', (R_CalcTexelDataSize(glt) + 1023) / 1024, loaded ? ']' : ' ', glt->inputtexels ? '[' : ' ', (glt->width * glt->height * glt->textype->inputbytesperpixel + 1023) / 1024, glt->inputtexels ? ']' : ' ', glt->crc, loaded ? "loaded" : "      ", (glt->flags & TEXF_MIPMAP) ? "mip" : "   ", (glt->flags & TEXF_ALPHA) ? "alpha" : "     ", glt->identifier ? glt->identifier : "<unnamed>");
		}
		Con_Printf("pool %10p\n", pool);
	}
	R_TextureStats_PrintTotal();
}

char engineversion[40];

static void r_textures_start(void)
{
	// deal with size limits of various drivers (3dfx in particular)
	glGetIntegerv(GL_MAX_TEXTURE_SIZE, &realmaxsize);
	CHECKGLERROR

	texturemempool = Mem_AllocPool("Textures");
	gltexnuminuse = Mem_Alloc(texturemempool, MAX_GLTEXTURES);
	//memset(gltexnuminuse, 0, MAX_GLTEXTURES);
}

static void r_textures_shutdown(void)
{
	rtexturepool_t *temp;
	while(gltexturepoolchain)
	{
		temp = (rtexturepool_t *) gltexturepoolchain;
		R_FreeTexturePool(&temp);
	}

	/*
	if (resizebuffer) Mem_Free(resizebuffer);resizebuffer = NULL;
	if (colorconvertbuffer) Mem_Free(colorconvertbuffer);colorconvertbuffer = NULL;
	if (resamplerow1) Mem_Free(resamplerow1);resamplerow1 = NULL;
	if (resamplerow2) Mem_Free(resamplerow2);resamplerow2 = NULL;
	if (texturebuffer) Mem_Free(texturebuffer);texturebuffer = NULL;
	if (gltexnuminuse) Mem_Free(gltexnuminuse);gltexnuminuse = NULL;
	*/
	resizebuffersize = 0;
	resamplerowsize = 0;
	texturebuffersize = 0;
	resizebuffer = NULL;
	colorconvertbuffer = NULL;
	resamplerow1 = NULL;
	resamplerow2 = NULL;
	texturebuffer = NULL;
	gltexnuminuse = NULL;
	Mem_FreePool(&texturemempool);
}

static void r_textures_newmap(void)
{
}

void R_Textures_Init (void)
{
	Cmd_AddCommand ("gl_texturemode", &GL_TextureMode_f);
	Cmd_AddCommand("r_texturestats", R_TextureStats_f);
	Cvar_RegisterVariable (&r_max_size);
	Cvar_RegisterVariable (&r_picmip);
	Cvar_RegisterVariable (&r_lerpimages);
	Cvar_RegisterVariable (&r_precachetextures);
	gltexnuminuse = NULL;

	R_RegisterModule("R_Textures", r_textures_start, r_textures_shutdown, r_textures_newmap);
}

static void R_ResampleTextureLerpLine (byte *in, byte *out, int inwidth, int outwidth, int bytesperpixel)
{
	int		j, xi, oldx = 0, f, fstep, endx, lerp;
	fstep = (int) (inwidth*65536.0f/outwidth);
	endx = (inwidth-1);
	if (bytesperpixel == 4)
	{
		for (j = 0,f = 0;j < outwidth;j++, f += fstep)
		{
			xi = f >> 16;
			if (xi != oldx)
			{
				in += (xi - oldx) * 4;
				oldx = xi;
			}
			if (xi < endx)
			{
				lerp = f & 0xFFFF;
				*out++ = (byte) ((((in[4] - in[0]) * lerp) >> 16) + in[0]);
				*out++ = (byte) ((((in[5] - in[1]) * lerp) >> 16) + in[1]);
				*out++ = (byte) ((((in[6] - in[2]) * lerp) >> 16) + in[2]);
				*out++ = (byte) ((((in[7] - in[3]) * lerp) >> 16) + in[3]);
			}
			else // last pixel of the line has no pixel to lerp to
			{
				*out++ = in[0];
				*out++ = in[1];
				*out++ = in[2];
				*out++ = in[3];
			}
		}
	}
	else if (bytesperpixel == 3)
	{
		for (j = 0,f = 0;j < outwidth;j++, f += fstep)
		{
			xi = f >> 16;
			if (xi != oldx)
			{
				in += (xi - oldx) * 3;
				oldx = xi;
			}
			if (xi < endx)
			{
				lerp = f & 0xFFFF;
				*out++ = (byte) ((((in[3] - in[0]) * lerp) >> 16) + in[0]);
				*out++ = (byte) ((((in[4] - in[1]) * lerp) >> 16) + in[1]);
				*out++ = (byte) ((((in[5] - in[2]) * lerp) >> 16) + in[2]);
			}
			else // last pixel of the line has no pixel to lerp to
			{
				*out++ = in[0];
				*out++ = in[1];
				*out++ = in[2];
			}
		}
	}
	else
		Sys_Error("R_ResampleTextureLerpLine: unsupported bytesperpixel %i\n", bytesperpixel);
}

/*
================
R_ResampleTexture
================
*/
static void R_ResampleTexture (void *indata, int inwidth, int inheight, void *outdata,  int outwidth, int outheight, int bytesperpixel)
{
	if (resamplerowsize < outwidth*4)
	{
		if (resamplerow1)
			Mem_Free(resamplerow1);
		if (resamplerow2)
			Mem_Free(resamplerow2);
		resamplerowsize = outwidth*4;
		resamplerow1 = Mem_Alloc(texturemempool, resamplerowsize);
		resamplerow2 = Mem_Alloc(texturemempool, resamplerowsize);
	}
#define row1 resamplerow1
#define row2 resamplerow2
	if (bytesperpixel == 4)
	{
		if (r_lerpimages.integer)
		{
			int		i, j, yi, oldy, f, fstep, lerp, endy = (inheight-1), inwidth4 = inwidth*4, outwidth4 = outwidth*4;
			byte	*inrow, *out;
			out = outdata;
			fstep = (int) (inheight*65536.0f/outheight);

			inrow = indata;
			oldy = 0;
			R_ResampleTextureLerpLine (inrow, row1, inwidth, outwidth, bytesperpixel);
			R_ResampleTextureLerpLine (inrow + inwidth4, row2, inwidth, outwidth, bytesperpixel);
			for (i = 0, f = 0;i < outheight;i++,f += fstep)
			{
				yi = f >> 16;
				if (yi < endy)
				{
					lerp = f & 0xFFFF;
					if (yi != oldy)
					{
						inrow = (byte *)indata + inwidth4*yi;
						if (yi == oldy+1)
							memcpy(row1, row2, outwidth4);
						else
							R_ResampleTextureLerpLine (inrow, row1, inwidth, outwidth, bytesperpixel);
						R_ResampleTextureLerpLine (inrow + inwidth4, row2, inwidth, outwidth, bytesperpixel);
						oldy = yi;
					}
					j = outwidth - 4;
					while(j >= 0)
					{
#define LERPBYTE(i) out[i] = (byte) ((((row2[i] - row1[i]) * lerp) >> 16) + row1[i])
						LERPBYTE( 0);
						LERPBYTE( 1);
						LERPBYTE( 2);
						LERPBYTE( 3);
						LERPBYTE( 4);
						LERPBYTE( 5);
						LERPBYTE( 6);
						LERPBYTE( 7);
						LERPBYTE( 8);
						LERPBYTE( 9);
						LERPBYTE(10);
						LERPBYTE(11);
						LERPBYTE(12);
						LERPBYTE(13);
						LERPBYTE(14);
						LERPBYTE(15);
						out += 16;
						row1 += 16;
						row2 += 16;
						j -= 4;
					}
					if (j & 2)
					{
						LERPBYTE( 0);
						LERPBYTE( 1);
						LERPBYTE( 2);
						LERPBYTE( 3);
						LERPBYTE( 4);
						LERPBYTE( 5);
						LERPBYTE( 6);
						LERPBYTE( 7);
						out += 8;
						row1 += 8;
						row2 += 8;
					}
					if (j & 1)
					{
						LERPBYTE( 0);
						LERPBYTE( 1);
						LERPBYTE( 2);
						LERPBYTE( 3);
						out += 4;
						row1 += 4;
						row2 += 4;
					}
					row1 -= outwidth4;
					row2 -= outwidth4;
				}
				else
				{
					if (yi != oldy)
					{
						inrow = (byte *)indata + inwidth4*yi;
						if (yi == oldy+1)
							memcpy(row1, row2, outwidth4);
						else
							R_ResampleTextureLerpLine (inrow, row1, inwidth, outwidth, bytesperpixel);
						oldy = yi;
					}
					memcpy(out, row1, outwidth4);
				}
			}
		}
		else
		{
			int i, j;
			unsigned frac, fracstep;
			// relies on int being 4 bytes
			int *inrow, *out;
			out = outdata;

			fracstep = inwidth*0x10000/outwidth;
			for (i = 0;i < outheight;i++)
			{
				inrow = (int *)indata + inwidth*(i*inheight/outheight);
				frac = fracstep >> 1;
				j = outwidth - 4;
				while (j >= 0)
				{
					out[0] = inrow[frac >> 16];frac += fracstep;
					out[1] = inrow[frac >> 16];frac += fracstep;
					out[2] = inrow[frac >> 16];frac += fracstep;
					out[3] = inrow[frac >> 16];frac += fracstep;
					out += 4;
					j -= 4;
				}
				if (j & 2)
				{
					out[0] = inrow[frac >> 16];frac += fracstep;
					out[1] = inrow[frac >> 16];frac += fracstep;
					out += 2;
				}
				if (j & 1)
				{
					out[0] = inrow[frac >> 16];frac += fracstep;
					out += 1;
				}
			}
		}
	}
	else if (bytesperpixel == 3)
	{
		if (r_lerpimages.integer)
		{
			int		i, j, yi, oldy, f, fstep, lerp, endy = (inheight-1), inwidth3 = inwidth * 3, outwidth3 = outwidth * 3;
			byte	*inrow, *out;
			out = outdata;
			fstep = (int) (inheight*65536.0f/outheight);

			inrow = indata;
			oldy = 0;
			R_ResampleTextureLerpLine (inrow, row1, inwidth, outwidth, bytesperpixel);
			R_ResampleTextureLerpLine (inrow + inwidth3, row2, inwidth, outwidth, bytesperpixel);
			for (i = 0, f = 0;i < outheight;i++,f += fstep)
			{
				yi = f >> 16;
				if (yi < endy)
				{
					lerp = f & 0xFFFF;
					if (yi != oldy)
					{
						inrow = (byte *)indata + inwidth3*yi;
						if (yi == oldy+1)
							memcpy(row1, row2, outwidth3);
						else
							R_ResampleTextureLerpLine (inrow, row1, inwidth, outwidth, bytesperpixel);
						R_ResampleTextureLerpLine (inrow + inwidth3, row2, inwidth, outwidth, bytesperpixel);
						oldy = yi;
					}
					j = outwidth - 4;
					while(j >= 0)
					{
#define LERPBYTE(i) out[i] = (byte) ((((row2[i] - row1[i]) * lerp) >> 16) + row1[i])
						LERPBYTE( 0);
						LERPBYTE( 1);
						LERPBYTE( 2);
						LERPBYTE( 3);
						LERPBYTE( 4);
						LERPBYTE( 5);
						LERPBYTE( 6);
						LERPBYTE( 7);
						LERPBYTE( 8);
						LERPBYTE( 9);
						LERPBYTE(10);
						LERPBYTE(11);
						out += 12;
						row1 += 12;
						row2 += 12;
						j -= 4;
					}
					if (j & 2)
					{
						LERPBYTE( 0);
						LERPBYTE( 1);
						LERPBYTE( 2);
						LERPBYTE( 3);
						LERPBYTE( 4);
						LERPBYTE( 5);
						out += 6;
						row1 += 6;
						row2 += 6;
					}
					if (j & 1)
					{
						LERPBYTE( 0);
						LERPBYTE( 1);
						LERPBYTE( 2);
						out += 3;
						row1 += 3;
						row2 += 3;
					}
					row1 -= outwidth3;
					row2 -= outwidth3;
				}
				else
				{
					if (yi != oldy)
					{
						inrow = (byte *)indata + inwidth3*yi;
						if (yi == oldy+1)
							memcpy(row1, row2, outwidth3);
						else
							R_ResampleTextureLerpLine (inrow, row1, inwidth, outwidth, bytesperpixel);
						oldy = yi;
					}
					memcpy(out, row1, outwidth3);
				}
			}
		}
		else
		{
			int i, j, f, inwidth3 = inwidth * 3;
			unsigned frac, fracstep;
			byte *inrow, *out;
			out = outdata;

			fracstep = inwidth*0x10000/outwidth;
			for (i = 0;i < outheight;i++)
			{
				inrow = (byte *)indata + inwidth3*(i*inheight/outheight);
				frac = fracstep >> 1;
				j = outwidth - 4;
				while (j >= 0)
				{
					f = (frac >> 16)*3;*out++ = inrow[f+0];*out++ = inrow[f+1];*out++ = inrow[f+2];frac += fracstep;
					f = (frac >> 16)*3;*out++ = inrow[f+0];*out++ = inrow[f+1];*out++ = inrow[f+2];frac += fracstep;
					f = (frac >> 16)*3;*out++ = inrow[f+0];*out++ = inrow[f+1];*out++ = inrow[f+2];frac += fracstep;
					f = (frac >> 16)*3;*out++ = inrow[f+0];*out++ = inrow[f+1];*out++ = inrow[f+2];frac += fracstep;
					j -= 4;
				}
				if (j & 2)
				{
					f = (frac >> 16)*3;*out++ = inrow[f+0];*out++ = inrow[f+1];*out++ = inrow[f+2];frac += fracstep;
					f = (frac >> 16)*3;*out++ = inrow[f+0];*out++ = inrow[f+1];*out++ = inrow[f+2];frac += fracstep;
					out += 2;
				}
				if (j & 1)
				{
					f = (frac >> 16)*3;*out++ = inrow[f+0];*out++ = inrow[f+1];*out++ = inrow[f+2];frac += fracstep;
					out += 1;
				}
			}
		}
	}
	else
		Sys_Error("R_ResampleTexture: unsupported bytesperpixel %i\n", bytesperpixel);
#undef row1
#undef row2
}

// in can be the same as out
static void R_MipReduce(byte *in, byte *out, int *width, int *height, int destwidth, int destheight, int bytesperpixel)
{
	int x, y, nextrow;
	nextrow = *width * bytesperpixel;
	if (*width > destwidth)
	{
		*width >>= 1;
		if (*height > destheight)
		{
			// reduce both
			*height >>= 1;
			if (bytesperpixel == 4)
			{
				for (y = 0;y < *height;y++)
				{
					for (x = 0;x < *width;x++)
					{
						out[0] = (byte) ((in[0] + in[4] + in[nextrow  ] + in[nextrow+4]) >> 2);
						out[1] = (byte) ((in[1] + in[5] + in[nextrow+1] + in[nextrow+5]) >> 2);
						out[2] = (byte) ((in[2] + in[6] + in[nextrow+2] + in[nextrow+6]) >> 2);
						out[3] = (byte) ((in[3] + in[7] + in[nextrow+3] + in[nextrow+7]) >> 2);
						out += 4;
						in += 8;
					}
					in += nextrow; // skip a line
				}
			}
			else if (bytesperpixel == 3)
			{
				for (y = 0;y < *height;y++)
				{
					for (x = 0;x < *width;x++)
					{
						out[0] = (byte) ((in[0] + in[3] + in[nextrow  ] + in[nextrow+3]) >> 2);
						out[1] = (byte) ((in[1] + in[4] + in[nextrow+1] + in[nextrow+4]) >> 2);
						out[2] = (byte) ((in[2] + in[5] + in[nextrow+2] + in[nextrow+5]) >> 2);
						out += 3;
						in += 6;
					}
					in += nextrow; // skip a line
				}
			}
			else
				Sys_Error("R_MipReduce: unsupported bytesperpixel %i\n", bytesperpixel);
		}
		else
		{
			// reduce width
			if (bytesperpixel == 4)
			{
				for (y = 0;y < *height;y++)
				{
					for (x = 0;x < *width;x++)
					{
						out[0] = (byte) ((in[0] + in[4]) >> 1);
						out[1] = (byte) ((in[1] + in[5]) >> 1);
						out[2] = (byte) ((in[2] + in[6]) >> 1);
						out[3] = (byte) ((in[3] + in[7]) >> 1);
						out += 4;
						in += 8;
					}
				}
			}
			else if (bytesperpixel == 3)
			{
				for (y = 0;y < *height;y++)
				{
					for (x = 0;x < *width;x++)
					{
						out[0] = (byte) ((in[0] + in[3]) >> 1);
						out[1] = (byte) ((in[1] + in[4]) >> 1);
						out[2] = (byte) ((in[2] + in[5]) >> 1);
						out += 3;
						in += 6;
					}
				}
			}
			else
				Sys_Error("R_MipReduce: unsupported bytesperpixel %i\n", bytesperpixel);
		}
	}
	else
	{
		if (*height > destheight)
		{
			// reduce height
			*height >>= 1;
			if (bytesperpixel == 4)
			{
				for (y = 0;y < *height;y++)
				{
					for (x = 0;x < *width;x++)
					{
						out[0] = (byte) ((in[0] + in[nextrow  ]) >> 1);
						out[1] = (byte) ((in[1] + in[nextrow+1]) >> 1);
						out[2] = (byte) ((in[2] + in[nextrow+2]) >> 1);
						out[3] = (byte) ((in[3] + in[nextrow+3]) >> 1);
						out += 4;
						in += 4;
					}
					in += nextrow; // skip a line
				}
			}
			else if (bytesperpixel == 3)
			{
				for (y = 0;y < *height;y++)
				{
					for (x = 0;x < *width;x++)
					{
						out[0] = (byte) ((in[0] + in[nextrow  ]) >> 1);
						out[1] = (byte) ((in[1] + in[nextrow+1]) >> 1);
						out[2] = (byte) ((in[2] + in[nextrow+2]) >> 1);
						out += 3;
						in += 3;
					}
					in += nextrow; // skip a line
				}
			}
			else
				Sys_Error("R_MipReduce: unsupported bytesperpixel %i\n", bytesperpixel);
		}
		else
			Sys_Error("R_MipReduce: desired size already achieved\n");
	}
}

static void R_Upload(gltexture_t *glt, byte *data)
{
	int mip, width, height, internalformat;
	byte *prevbuffer;
	prevbuffer = data;

	glBindTexture(GL_TEXTURE_2D, glt->image->texnum);
	CHECKGLERROR

	glt->flags &= ~GLTEXF_UPLOAD;

	if (glt->flags & TEXF_FRAGMENT)
	{
		if (resizebuffersize < glt->image->width * glt->image->height * glt->image->bytesperpixel)
		{
			resizebuffersize = glt->image->width * glt->image->height * glt->image->bytesperpixel;
			if (resizebuffer)
				Mem_Free(resizebuffer);
			if (colorconvertbuffer)
				Mem_Free(colorconvertbuffer);
			resizebuffer = Mem_Alloc(texturemempool, resizebuffersize);
			colorconvertbuffer = Mem_Alloc(texturemempool, resizebuffersize);
			if (!resizebuffer || !colorconvertbuffer)
				Host_Error("R_Upload: out of memory\n");
		}

		if (glt->image->flags & GLTEXF_UPLOAD)
		{
			glt->image->flags &= ~GLTEXF_UPLOAD;
			memset(resizebuffer, 255, glt->image->width * glt->image->height * glt->image->bytesperpixel);
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_mag);
			CHECKGLERROR
			glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_mag);
			CHECKGLERROR
			glTexImage2D (GL_TEXTURE_2D, 0, glt->image->glinternalformat, glt->image->width, glt->image->height, 0, glt->image->glformat, GL_UNSIGNED_BYTE, resizebuffer);
			CHECKGLERROR
		}

		if (prevbuffer == NULL)
		{
			memset(resizebuffer, 255, glt->width * glt->height * glt->image->bytesperpixel);
			prevbuffer = resizebuffer;
		}
		else if (glt->textype->textype == TEXTYPE_QPALETTE)
		{
			// promote paletted to RGBA, so we only have to worry about RGB and
			// RGBA in the rest of this code
			Image_Copy8bitRGBA(prevbuffer, colorconvertbuffer, glt->width * glt->height, d_8to24table);
			prevbuffer = colorconvertbuffer;
		}

		glTexSubImage2D(GL_TEXTURE_2D, 0, glt->x, glt->y, glt->width, glt->height, glt->image->glformat, GL_UNSIGNED_BYTE, prevbuffer);
		CHECKGLERROR
		return;
	}

	glt->image->flags &= ~GLTEXF_UPLOAD;

	// these are rounded up versions of the size to do better resampling
	width = 1;while(width < glt->width) width *= 2;
	height = 1;while(height < glt->height) height *= 2;

	if (resizebuffersize < width * height * glt->image->bytesperpixel)
	{
		resizebuffersize = width * height * glt->image->bytesperpixel;
		if (resizebuffer)
			Mem_Free(resizebuffer);
		if (colorconvertbuffer)
			Mem_Free(colorconvertbuffer);
		resizebuffer = Mem_Alloc(texturemempool, resizebuffersize);
		colorconvertbuffer = Mem_Alloc(texturemempool, resizebuffersize);
		if (!resizebuffer || !colorconvertbuffer)
			Host_Error("R_Upload: out of memory\n");
	}

	if (prevbuffer == NULL)
	{
		width = glt->image->width;
		height = glt->image->height;
		memset(resizebuffer, 255, width * height * glt->image->bytesperpixel);
		prevbuffer = resizebuffer;
	}
	else
	{
		if (glt->textype->textype == TEXTYPE_QPALETTE)
		{
			// promote paletted to RGBA, so we only have to worry about RGB and
			// RGBA in the rest of this code
			Image_Copy8bitRGBA(prevbuffer, colorconvertbuffer, glt->width * glt->height, d_8to24table);
			prevbuffer = colorconvertbuffer;
		}

		if (glt->width != width || glt->height != height)
		{
			R_ResampleTexture(prevbuffer, glt->width, glt->height, resizebuffer, width, height, glt->image->bytesperpixel);
			prevbuffer = resizebuffer;
		}

		// apply picmip/max_size limitations
		while (width > glt->image->width || height > glt->image->height)
		{
			R_MipReduce(prevbuffer, resizebuffer, &width, &height, glt->image->width, glt->image->height, glt->image->bytesperpixel);
			prevbuffer = resizebuffer;
		}
	}

	// 3 and 4 are converted by the driver to it's preferred format for the current display mode
	internalformat = 3;
	if (glt->flags & TEXF_ALPHA)
		internalformat = 4;

	mip = 0;
	glTexImage2D(GL_TEXTURE_2D, mip++, internalformat, width, height, 0, glt->image->glformat, GL_UNSIGNED_BYTE, prevbuffer);
	CHECKGLERROR
	if (glt->flags & TEXF_MIPMAP)
	{
		while (width > 1 || height > 1)
		{
			R_MipReduce(prevbuffer, resizebuffer, &width, &height, 1, 1, glt->image->bytesperpixel);
			prevbuffer = resizebuffer;

			glTexImage2D(GL_TEXTURE_2D, mip++, internalformat, width, height, 0, glt->image->glformat, GL_UNSIGNED_BYTE, prevbuffer);
			CHECKGLERROR
		}

		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_min);
		CHECKGLERROR
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_mag);
		CHECKGLERROR
	}
	else
	{
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, gl_filter_mag);
		CHECKGLERROR
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, gl_filter_mag);
		CHECKGLERROR
	}
}

static void R_FindImageForTexture(gltexture_t *glt)
{
	int i, j, best, best2, x, y, w, h;
	textypeinfo_t *texinfo;
	gltexturepool_t *pool;
	gltextureimage_t *image, **imagechainpointer;
	texinfo = glt->textype;
	pool = glt->pool;

	x = 0;
	y = 0;
	w = glt->width;
	h = glt->height;
	if (glt->flags & TEXF_FRAGMENT)
	{
		for (imagechainpointer = &pool->imagechain;*imagechainpointer;imagechainpointer = &(*imagechainpointer)->imagechain)
		{
			image = *imagechainpointer;
			if (image->type != GLIMAGETYPE_FRAGMENTS)
				continue;
			if (image->glformat != texinfo->glformat || image->glinternalformat != texinfo->glinternalformat)
				continue;

			// got a fragments texture, find a place in it if we can
			best = BLOCK_SIZE;
			for (best = BLOCK_SIZE, i = 0;i < BLOCK_SIZE - w;i += texinfo->align)
			{
				for (best2 = 0, j = 0;j < w;j++)
				{
					if (image->blockallocation[i+j] >= best)
						break;
					if (best2 < image->blockallocation[i+j])
						best2 = image->blockallocation[i+j];
				}
				if (j == w)
				{
					// this is a valid spot
					x = i;
					y = best = best2;
				}
			}

			if (best + h > BLOCK_SIZE)
				continue;

			for (i = 0;i < w;i++)
				image->blockallocation[x + i] = best + h;

			glt->x = x;
			glt->y = y;
			glt->image = image;
			image->texturecount++;
			return;
		}

		image = Mem_Alloc(texturemempool, sizeof(gltextureimage_t));
		if (image == NULL)
			Sys_Error("R_FindImageForTexture: ran out of memory\n");
		//memset(image, 0, sizeof(*image));
		image->type = GLIMAGETYPE_FRAGMENTS;
		image->width = BLOCK_SIZE;
		image->height = BLOCK_SIZE;
		image->blockallocation = Mem_Alloc(texturemempool, BLOCK_SIZE * sizeof(short));
		memset(image->blockallocation, 0, BLOCK_SIZE * sizeof(short));

		x = 0;
		y = 0;
		for (i = 0;i < w;i++)
			image->blockallocation[x + i] = y + h;
	}
	else
	{
		for (imagechainpointer = &pool->imagechain;*imagechainpointer;imagechainpointer = &(*imagechainpointer)->imagechain);

		image = Mem_Alloc(texturemempool, sizeof(gltextureimage_t));
		if (image == NULL)
			Sys_Error("R_FindImageForTexture: ran out of memory\n");
		//memset(image, 0, sizeof(*image));
		image->type = GLIMAGETYPE_TILE;
		image->blockallocation = NULL;

		// calculate final size
		if (r_max_size.integer > realmaxsize)
			Cvar_SetValue("r_max_size", realmaxsize);
		image->width = 1;while (image->width < glt->width) image->width <<= 1;
		image->height = 1;while (image->height < glt->height) image->height <<= 1;
		image->width >>= r_picmip.integer;while (image->width > r_max_size.integer) image->width >>= 1;
		image->height >>= r_picmip.integer;while (image->height > r_max_size.integer) image->height >>= 1;
		if (image->width < 1) image->width = 1;
		if (image->height < 1) image->height = 1;
	}
	image->glinternalformat = texinfo->glinternalformat;
	image->glformat = texinfo->glformat;
	image->flags = (glt->flags & (TEXF_MIPMAP | TEXF_ALPHA)) | GLTEXF_UPLOAD;
	image->bytesperpixel = texinfo->internalbytesperpixel;
	for (i = 1;i < MAX_GLTEXTURES;i++)
		if (!gltexnuminuse[i])
			break;
	if (i < MAX_GLTEXTURES)
		gltexnuminuse[image->texnum = i] = true;
	else
		Sys_Error("R_FindImageForTexture: ran out of GL textures\n");
	*imagechainpointer = image;
	image->texturecount++;

	glt->x = x;
	glt->y = y;
	glt->image = image;
}

// note: R_FindImageForTexture must be called before this
static void R_UploadTexture (gltexture_t *glt)
{
	if (!(glt->flags & (GLTEXF_UPLOAD | GLTEXF_PROCEDURAL)))
		return;

	if (glt->flags & GLTEXF_PROCEDURAL)
	{
		if (glt->generate)
		{
			if (texturebuffersize < glt->width * glt->height * glt->textype->inputbytesperpixel)
			{
				if (texturebuffer)
					Mem_Free(texturebuffer);
				texturebuffersize = glt->width * glt->height * glt->textype->inputbytesperpixel;
				texturebuffer = Mem_Alloc(texturemempool, texturebuffersize);
			}

			glt->generate(texturebuffer, glt->width, glt->height, (void *)glt->proceduraldata, glt->proceduraldatasize);
		}
	}
	else
	{
		R_Upload(glt, glt->inputtexels);
		if (glt->inputtexels)
		{
			Mem_Free(glt->inputtexels);
			glt->inputtexels = NULL;
			glt->flags |= GLTEXF_DESTROYED;
		}
		else if (glt->flags & GLTEXF_DESTROYED)
			Con_Printf("R_UploadTexture: Texture %s already uploaded and destroyed.  Can not upload original image again.  Uploaded blank texture.\n", glt->identifier);
	}
}

static gltexture_t *R_SetupTexture(gltexturepool_t *pool, char *identifier, int crc, int width, int height, int flags, textypeinfo_t *texinfo, byte *data, int (*generate)(byte *buffer, int width, int height, void *proceduraldata, int proceduraldatasize), void *proceduraldata, int proceduraldatasize)
{
	gltexture_t *glt;
	glt = Mem_Alloc(texturemempool, sizeof(gltexture_t));
	//memset(glt, 0, sizeof(gltexture_t));
	if (identifier)
	{
		glt->identifier = Mem_Alloc(texturemempool, strlen(identifier)+1);
		strcpy (glt->identifier, identifier);
	}
	else
		glt->identifier = NULL;
	glt->pool = pool;
	glt->chain = pool->gltchain;
	pool->gltchain = glt;
	glt->crc = crc;
	glt->width = width;
	glt->height = height;
	glt->flags = flags;
	glt->textype = texinfo;

	if (data)
	{
		glt->inputtexels = Mem_Alloc(texturemempool, glt->width * glt->height * texinfo->inputbytesperpixel);
		if (glt->inputtexels == NULL)
			Sys_Error("R_SetupTexture: out of memory\n");
		memcpy(glt->inputtexels, data, glt->width * glt->height * texinfo->inputbytesperpixel);
	}
	else
		glt->inputtexels = NULL;

	glt->generate = generate;
	glt->proceduraldatasize = proceduraldatasize;
	if (proceduraldatasize)
	{
		glt->proceduraldata = Mem_Alloc(texturemempool, proceduraldatasize);
		if (glt->proceduraldata == NULL)
			Sys_Error("R_SetupTexture: out of memory\n");
	}
	else
		glt->proceduraldata = NULL;

	R_FindImageForTexture(glt);
	R_PrecacheTexture(glt);

	return glt;
}

/*
================
R_LoadTexture
================
*/
rtexture_t *R_LoadTexture (rtexturepool_t *rtexturepool, char *identifier, int width, int height, byte *data, int textype, int flags)
{
	int i;
	gltexture_t *glt;
	gltexturepool_t *pool = (gltexturepool_t *)rtexturepool;
	textypeinfo_t *texinfo;
	unsigned short crc;

	if (cls.state == ca_dedicated)
		return NULL;

	texinfo = R_GetTexTypeInfo(textype, flags);

	// data can be NULL
//	if (data == NULL)
//		Host_Error("R_LoadTexture: \"%s\" has no data\n", identifier);

	if (flags & TEXF_FRAGMENT)
	{
		if (width > BLOCK_SIZE || height > BLOCK_SIZE)
			Host_Error("R_LoadTexture: fragment too big, must be no more than %dx%d\n", BLOCK_SIZE, BLOCK_SIZE);
		if ((width * texinfo->internalbytesperpixel) & 3)
			Host_Error("R_LoadTexture: incompatible width for fragment");
	}

	// clear the alpha flag if the texture has no transparent pixels
	switch(textype)
	{
	case TEXTYPE_QPALETTE:
		if (flags & TEXF_ALPHA)
		{
			flags &= ~TEXF_ALPHA;
			for (i = 0;i < width * height;i++)
			{
				if (data[i] == 255)
				{
					flags |= TEXF_ALPHA;
					break;
				}
			}
		}
		break;
	case TEXTYPE_RGB:
		if (flags & TEXF_ALPHA)
			Host_Error("R_LoadTexture: RGB has no alpha, don't specify TEXF_ALPHA\n");
		break;
	case TEXTYPE_RGBA:
		if (flags & TEXF_ALPHA)
		{
			flags &= ~TEXF_ALPHA;
			for (i = 0;i < width * height;i++)
			{
				if (data[i * 4 + 3] < 255)
				{
					flags |= TEXF_ALPHA;
					break;
				}
			}
		}
		break;
	default:
		Host_Error("R_LoadTexture: unknown texture type\n");
	}

	// LordHavoc: do a CRC to confirm the data really is the same as previous occurances.
	if (data == NULL)
		crc = 0;
	else
		crc = CRC_Block(data, width*height*texinfo->inputbytesperpixel);

	// see if the texture is already present
	if (identifier && (glt = R_FindTexture(pool, identifier)))
	{
		if (crc == glt->crc && width == glt->width && height == glt->height && texinfo == glt->textype && ((flags ^ glt->flags) & TEXF_IMPORTANTBITS) == 0 && ((flags ^ glt->flags) & GLTEXF_IMPORTANTBITS) == 0)
			return (rtexture_t *)glt; // exact match, use existing
		Con_Printf("R_LoadTexture: cache mismatch on %s, replacing old texture\n", identifier);
		R_FreeTexture(glt);
	}

	return (rtexture_t *)R_SetupTexture(pool, identifier, crc, width, height, flags | GLTEXF_UPLOAD, texinfo, data, NULL, NULL, 0);
}

rtexture_t *R_ProceduralTexture (rtexturepool_t *rtexturepool, char *identifier, int width, int height, int textype, int flags, int (*generate)(byte *buffer, int width, int height, void *proceduraldata, int proceduraldatasize), void *proceduraldata, int proceduraldatasize)
{
	gltexture_t		*glt;
	gltexturepool_t	*pool = (gltexturepool_t *)rtexturepool;
	textypeinfo_t	*texinfo;

	if (cls.state == ca_dedicated)
		return NULL;

	texinfo = R_GetTexTypeInfo(textype, flags);

	// no function is supported, for odd uses
//	if (generate == NULL)
//		Host_Error("R_ProceduralTexture: \"%s\" has no generate function\n", identifier);
	if (flags & TEXF_FRAGMENT)
	{
		if (width > BLOCK_SIZE || height > BLOCK_SIZE)
			Host_Error("R_ProceduralTexture: fragment too big, must be no more than %dx%d\n", BLOCK_SIZE, BLOCK_SIZE);
		if ((width * texinfo->internalbytesperpixel) & 3)
			Host_Error("R_ProceduralTexture: incompatible width for fragment");
	}

	// see if the texture is already present
	if (identifier && (glt = R_FindTexture(pool, identifier)))
	{
		if (width == glt->width && height == glt->height && texinfo == glt->textype && ((flags ^ glt->flags) & TEXF_IMPORTANTBITS) == 0 && ((flags ^ glt->flags) & GLTEXF_IMPORTANTBITS) == 0)
			return (rtexture_t *)glt; // exact match, use existing
		Con_DPrintf("R_LoadTexture: cache mismatch, replacing old texture\n");
		R_FreeTexture(glt);
	}

	return (rtexture_t *)R_SetupTexture(pool, identifier, 0, width, height, flags | GLTEXF_PROCEDURAL | GLTEXF_UPLOAD, texinfo, NULL, generate, proceduraldata, proceduraldatasize);
}

int R_TextureHasAlpha(rtexture_t *rt)
{
	gltexture_t *glt;
	if (!rt)
		return false;
	glt = (gltexture_t *)rt;
	return (glt->flags & TEXF_ALPHA) != 0;
}

int R_TextureWidth(rtexture_t *rt)
{
	if (!rt)
		return false;
	return ((gltexture_t *)rt)->width;
}

int R_TextureHeight(rtexture_t *rt)
{
	if (!rt)
		return false;
	return ((gltexture_t *)rt)->height;
}

void R_GetFragmentLocation(rtexture_t *rt, int *x, int *y, float *fx1, float *fy1, float *fx2, float *fy2)
{
	gltexture_t *glt;
	float iwidth, iheight;
	if (cls.state == ca_dedicated)
	{
		if (x)
			*x = 0;
		if (y)
			*y = 0;
		if (fx1 || fy1 || fx2 || fy2)
		{
			if (fx1)
				*fx1 = 0;
			if (fy1)
				*fy1 = 0;
			if (fx2)
				*fx2 = 1;
			if (fy2)
				*fy2 = 1;
		}
		return;
	}
	if (!rt)
		Host_Error("R_GetFragmentLocation: no texture supplied\n");
	glt = (gltexture_t *)rt;
	if (glt->flags & TEXF_FRAGMENT)
	{
		if (x)
			*x = glt->x;
		if (y)
			*y = glt->y;
		if (fx1 || fy1 || fx2 || fy2)
		{
			iwidth = 1.0f / glt->image->width;
			iheight = 1.0f / glt->image->height;
			if (fx1)
				*fx1 = glt->x * iwidth;
			if (fy1)
				*fy1 = glt->y * iheight;
			if (fx2)
				*fx2 = (glt->x + glt->width) * iwidth;
			if (fy2)
				*fy2 = (glt->y + glt->height) * iheight;
		}
	}
	else
	{
		if (x)
			*x = 0;
		if (y)
			*y = 0;
		if (fx1 || fy1 || fx2 || fy2)
		{
			if (fx1)
				*fx1 = 0;
			if (fy1)
				*fy1 = 0;
			if (fx2)
				*fx2 = 1;
			if (fy2)
				*fy2 = 1;
		}
	}
}

int R_CompatibleFragmentWidth(int width, int textype, int flags)
{
	textypeinfo_t *texinfo = R_GetTexTypeInfo(textype, flags);
	while ((width * texinfo->internalbytesperpixel) & 3)
		width++;
	return width;
}

void R_UpdateTexture(rtexture_t *rt, byte *data)
{
	gltexture_t *glt;
	if (rt == NULL)
		Host_Error("R_UpdateTexture: no texture supplied\n");
	if (data == NULL)
		Host_Error("R_UpdateTexture: no data supplied\n");
	glt = (gltexture_t *)rt;
	if (!(glt->flags & GLTEXF_PROCEDURAL))
	{
		if (glt->inputtexels == NULL)
		{
			glt->inputtexels = Mem_Alloc(texturemempool, glt->width * glt->height * glt->textype->inputbytesperpixel);
			if (glt->inputtexels == NULL)
				Host_Error("R_UpdateTexture: ran out of memory\n");
		}
		memcpy(glt->inputtexels, data, glt->width * glt->height * glt->textype->inputbytesperpixel);
	}
	R_Upload(glt, data);
}

